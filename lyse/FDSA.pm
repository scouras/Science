#!/usr/bin/perl

package Lyse::FDSA;

use strict;
use warnings;
use Utility qw(:all);
use Data::Dumper;
use Ilmm;

# Not actually exporting anything
require Exporter;
our @ISA = qw(Exporter);
our %EXPORT_TAGS = ('all' => [qw()]);
our @EXPORT_OK = (@{$EXPORT_TAGS{'all'}});
our @EXPORT = qw();

# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.4 $'              =~ /^.Revision: (.*) \$/; our $REVISION   = $1;
'$Date: 2009/02/06 02:37:27 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;


############################################## DEFAULT CONFIGURATION

our %CONFIG_ANAL = (

  revision        => $REVISION,
  checked_in      => $CHECKED_IN,
  author          => $AUTHOR,

  subtype         => '',
  resolution      => 10,
  max_simultaneous=>  2,
  dependencies    => [],
  
  dir_anal        => 'fdsa',
  file_data       => 'summary.dat',
  reference       => 'min.pdb',

  plot_machine    => 'medusa',
  overwrite_anal  => 0,
  overwrite_plots => 0,
  start_emphasis  => 20,
  final_emphasis  => 20,
  width           => 1024,
  height          => 768,
  threads         => 2,
  
  min_log_size    => 1024,
  is_plotted      => 1,
  wait_to_finish  => 0,
  queue           => 'opterons',
  #queue_force     => 'xs',
  #queue           => 'analysis',
  plot_command    => "/users/scouras/public/plot_fdsa",
  plot_command_dev=> "/users/scouras/code/scouras/plot_fdsa",
  plot_command    => "/users/scouras/code/scouras/plot_fdsa",
  plot_files      => [],

);




######################################################### INITIALIZE

sub New {
  return bless {
    name => 'FDSA',
    %CONFIG_ANAL,
  };
}

sub Initialize {
  my $CONFIG_ANAL = $_[0];
  
  my %CONFIG_GLOBAL = $_[1] ? %{$_[1]} : ();
  my $ANAL = { 
    %$CONFIG_ANAL, 
    %CONFIG_GLOBAL,
  };

  if ( $CONFIG_GLOBAL{'development'} ) { 
    $CONFIG_ANAL{'plot_command'} = $CONFIG_ANAL{"plot_command_dev"};
  }

  $ANAL->{'title'} = $CONFIG_ANAL->{'name'};
  if ( $ANAL->{'subtype'} ) { 
    $ANAL->{'title'} .= " $ANAL->{'subtype'}";
  }
  return bless $ANAL;
}




########################################################### GET JOBS

sub Get_Jobs {

  my $ANAL    = $_[0];
  my $ILMM    = $_[1];
  my $REGION  = $_[2];

  # FDSA only executes on whole molecules
  if ( not defined $REGION->{'molecule'} ) { return (); }
  if ( not defined $REGION->{'index'   } ) { return (); }
  return () if not $REGION->{'index'} == 0;

#  # Directory Information
#  my $path_base = "$ILMM->{'dir'}/$ANAL->{'dir_data'}";
#  my $path_anal = "$path_base/$REGION->{'index'}\_$REGION->{'name'}";
#  my $path_data = "$path_anal/$ANAL->{'file_data'}";

  # SET UP JOB
  my $job = Lyse::Job::new ( $ANAL, $ILMM, $REGION, $ANAL->{'title'} );
  $job->{'resolution' } = $ANAL->{'resolution'};
  $job->{'line'       } = "fdsa intra hbonds hphobs others";
  $job->{'path_base'  } = $job->{'path_anal'};
  $job->{'dir_anal'   } = "$job->{'dir_anal'}/$REGION->{'index'}_$REGION->{'name'}";
  $job->{'path_anal'  } = "$ILMM->{'dir'}/$job->{'dir_anal'}";
  $job->Add_Data($ANAL->{'file_data'});
  
  $job->{'images'     } = [];
  $job->{'data_files' } = [];
  
  $job->{'title_prefix'} = "FDSA - ";
  $job->{'title_suffix'} = " - $job->{'region'}{'title_full'}";

  $job->Validate_Initial();

  # Time regions in FDSA do not run their own job, 
  # they just plot a subregion of the existing data.
  # So they either plot or do nothing at all.
  if ( $REGION->{'period'} ) { 
    if ( not $job->{'status'}{'valid'} ) { 
      
      return;
    }
  }




  # Sweet!  Something worked for once.
  if ( $job->{'status'}{'valid'} ) {
    # noop

  # OK, well, we'll work with what we have then.
  } elsif ( -e $job->{'path_base'} and not $ANAL->{'strict_plot'} ) { 
    print "Delete OLD FDSA dir to run new job ($job->{'status'}{'initial'}) $job->{'path_base'}\n";
    $job->{'status'}{'valid'} = 1;

  # Subjobs only plot, and stay out of the affairs of running real jobs
  } elsif ( $REGION->{'period'} ) { 
    $job->{'status'}{'valid'} = 1;
    $job->{'status'}{'complete'} = 1;
 
  # OK, Actually run the job:
  # Can only run $ANAL->{'max_simultaneous'} analyses at the 
  # same time so as not to kill file systems.  Implemented
  # with a dependency buffer.
  } else { 

    if ( scalar(@{$ANAL->{'dependencies'}}) >= $ANAL->{'max_simultaneous'} ) { 
      $job->{'dependency'} = shift @{$ANAL->{'dependencies'}};
    }  
    push @{$ANAL->{'dependencies'}}, $job;
  }

  if ( wantarray ) { return ($job) }
  else             { return [$job] }
}



###################################################### VALIDATE JOBS
sub Validate_Job {

  my $ANAL = $_[0];
  my $job  = $_[1];

  my $dir = $job->{'path_anal'};
  my $ILMM = $job->{'ilmm'};

#  if ( -e $job->{'path_data'} ) { return 1 }

  # Verify that dir and data files exist
  if ( $ANAL->{'overwrite_anal'}  ) { return (0, "forced overwrite" ) }
  my ($valid, $message);
  ($valid, $message) = 
    Lyse::Job::Basic_Data_Check($job->{'path_anal'}, $job->{'path_data'});
  return ($valid, $message) if not $valid;
  ($valid, $message) = 
    Lyse::Job::Basic_Data_Time_Check( $job->{'path_data'}, 
                                $ILMM->{'start_time'},
                                $ILMM->{'finish_time'},
                                $ANAL->{'resolution'} );
  return ($valid, $message) if not $valid;

  $job->{'valid'   } = 1;
  return 1;
}




##################################################### VALIDATE PLOTS

sub Validate_Plot {

  my $ANAL = $_[0];
  my $job  = $_[1];
  my $ILMM = $job->{'ilmm'};

  my @plot_files = @{$ANAL->{'plot_files'}};
  my $path_data = $job->{'path_data'};
  my $valid = 1;

  $job->{'images'} = [];

  my $message;
  foreach my $plot_file (@plot_files) { 

    my $TITLE = `grep TITLE $plot_file`;
    $TITLE =~ /TITLE\s+(.*)$/ or next;
    my $title = Utility::Trim($1);
    my $prefix = lc Utility::Clean_Filename($job->{'title_prefix'} . $title . $job->{'title_suffix'});
    my $path_image = "$job->{'path_base'}/$prefix.png";
    my $path_info  = "$job->{'path_base'}/$prefix.info";
    my $path_time  = "$job->{'path_base'}/$prefix.time";
    my $path_gplt  = "$job->{'path_base'}/$prefix.gplt";
    my $path_log   = "$job->{'path_base'}/$prefix.log";
    
    push @{$job->{'images'}}, $path_image;
    push @{$job->{'data_files'}}, $path_info, $path_time;
    #print "Looking for image $path_image\n";
    

    ##### MAJOR VALIDATION CHECKS
    $message = "";
    foreach my $file ( $path_info, $path_time, $path_log ) { 

      if    ( not -e $file                ) { $message = "missing file ($file)" }
      elsif ( -z $file                    ) { $message = "empty file ($file)" }
      elsif ( $ANAL->{'overwrite_plots'}  ) { $message = "forced overwrite" }
      elsif ( -M $file > -M $path_data    ) { $message = "old file ($file)" }

      if ( $message ) { 
        $job->{'replot'}{$plot_file} = 1; 
        $valid = 0; 
        #print "Not valid $message for $plot_file\n";
        last;
      }
      #print "Found it.\n" if not $message;
    }

    ##### ADDITIONAL CHECKS 
    
    # Log file far too small
    my $log_size = -s $path_log;
    if ( $valid and $log_size < $ANAL->{'min_log_size'}) { 
      $job->{'replot'}{$plot_file} = 1;
      $valid = 0;
      $message = "corrupted log file ($log_size, $path_log)";
    }
    
    # Integer pointsize bug (must be floats for line to show up properly)
    if ( $valid and -e $path_gplt ) { 
      my $pointsize = (split '=', `grep "^pointsize" $path_gplt`)[1];
      if ( not $pointsize ) { 
        $job->{'replot'}{$plot_file} = 1;
        $valid = 0;
        $message = "corrupted gplt ($path_gplt)";
      } else { 
        chomp $pointsize;
        if ( $pointsize =~ /^\d+$/ ) { 
          $job->{'replot'}{$plot_file} = 1;
          $valid = 0;
          $message = "bad pointsize ($pointsize, $path_gplt)";
        }
      }
    }

    # .TIME file contains sufficient timepoints
    if ( $valid ) { 
      my $final_time = (split /\s+/, `head -n 1 $path_time`)[-1];
      if ( $final_time < ($ILMM->{'finish_time'}-2000) ) {
        $job->{'replot'}{$plot_file} = 1;
        $valid = 0;
        $message = "not enough timepoints in time file ($final_time)";
      }
    }


    #if ( $message ) { 
    #  print "\nNot valid: $plot_file, $message\n";
    #}
  }
  if ( not $valid ) { return ( 0, "missing plots ($message)" ) }
  return 1;
}



########################################################### PLOT JOB

sub Plot_Job {

  my $ANAL = $_[0];
  my $job  = $_[1];

  my @plot_files = @{$ANAL->{'plot_files'}};

  return 0 if not -e $job->{'path_base'};

  my @messages = ();
  foreach my $plot_file (@plot_files) { 

    next if not $job->{'replot'}{$plot_file};

    print "REPLOTTING $plot_file\n";

    my $TITLE = `grep TITLE $plot_file`;
    $TITLE =~ /TITLE\s+(.*)$/ or next;
    my $title = Utility::Trim($1);
    my $prefix_image = lc Utility::Clean_Filename($job->{'title_prefix'} . $title . $job->{'title_suffix'});
    my $path_image = "$job->{'path_base'}/$prefix_image.png";
    my $path_gplt  = "$job->{'path_base'}/$prefix_image.gplt";
    my $path_time  = "$job->{'path_base'}/$prefix_image.time";
    my $path_info  = "$job->{'path_base'}/$prefix_image.info";
    my $path_log   = "$job->{'path_base'}/$prefix_image.log";

    foreach my $file ( $path_image, $path_gplt, $path_time, $path_info, $path_log ) { 
      if ( -e $file ) { 
        unlink $file  or die "Couldn't delete fdsa file, '$file'. $!";
      }
    }
    
    my $plot_command = 
          "(time ssh $ANAL->{'plot_machine'} "
          . $ANAL->{'plot_command'} . " "
          . $job->{'dir'} . " "
          . $plot_file . " "
          . "--prefix=\\\"$job->{'title_prefix'}\\\" "
          . "--suffix=\\\"$job->{'title_suffix'}\\\" "
          . ( $job->{'period'} ? "--start_cutoff=$job->{'period'}[0]ns --end_cutoff=$job->{'period'}[1]ns" : "")
          . ") &> $path_log"
          ;
    #print "$plot_command\n";
    #next;
    my $result = system ( $plot_command );
    if ( $result ) {
      push @messages, $plot_file;
    }
  }
  if ( @messages ) {
    my $message = "plot_fdsa failed on files (" 
                . (join ',', @messages)
                . ")";
    $job->{'status'}{'error'} = $message;
    return ( 0, $message);
  } else { 
    $job->{'status'}{'plotted'} = 1;
    return 1;
  }
}




1

