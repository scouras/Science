#! /usr/bin/perl

package Lyse;

####################################################################
# Lyse
# by Alex Scouras <scouras@u.washington.edu>
# Created 27 June 2008 (derived from generate_analysis)
#-------------------------------------------------------------------
# Monitors simulations and performs analyses when appropriate
# 
# 
#-------------------------------------------------------------------
# GENERAL STRUCTURE OF LYSE
# 1) Load parameters
# 2) Load simulation list
# 3) Load/configure analysis modules
# 4) For each simulation group
# 4 a) For each simulation replicate
# 4 a 1) Prepare .is .i .etc
# 4 a 2) Determine status
# 4 a 2) For each analysis
# 4 a 2 a) Determine if needs running
# 4 a 2 b) Set up run parameters
# 4 a 3) Run batch analyses
# 4 a 4) For each analysis
# 4 a 4 a) Verify
# 4 a 4 b) Plot
# 4 a 5) Collect plots (simulation)
# 4 b) Collect plots (group)
#-------------------------------------------------------------------
# GENERAL STRUCTURE OF A LYSE MODULE (IN SUBROUTINES)
# 1) Default parameters
# 2) Check_Simulation()
# 2 a) Determine if analysis needs to be run
# 2 b) Report how to perform analysis
# 2 c) Set parameters
# 2 d) Machine to perform analysis on (if separate)
# 3) Verify_Analysis ()
# 4) Plot_Simulations()
# 4 a) Execute list of programs to run for plotting
#-------------------------------------------------------------------
# TODO LIST
# Add time periods
# Homodimers
# Heterodimers
# detect that a simulation is finished and set leniency to 0 ps / 0 days
# 
####################################################################

# MODULE INFORMATION
my $DEVELOPMENT;
my $REVISION;
my $CHECKED_IN;
my $AUTHOR;

# CURRENT EXECUTION INFORMATION
my $PWD;
my $HOST;
my $TIME;
my $USER;


BEGIN{

  $DEVELOPMENT = 1;

  # CURRENT EXECUTION INFORMATION
  $PWD   = `pwd`;        chomp $PWD;
  $HOST  = `hostname`;   chomp $HOST;
  $TIME  = `date`;       chomp $TIME;
  $USER  = `whoami`;     chomp $USER;

  # CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
  '$Revision: 1.7 $'              =~ /^.Revision: (.*) \$/;   $REVISION   = $1;
  '$Date: 2009/04/29 22:10:54 $'  =~ /^.Date: (.*) \$/;       $CHECKED_IN = $1;
  '$Author: scouras $'            =~ /^.Author: (.*) \$/;     $AUTHOR     = $1;

  if ( $DEVELOPMENT ) { 
  #if ( $DEVELOPMENT and $USER eq 'scouras' ) {  # more pain than it's often worth
    print "Using development versions\n";
    push @INC,
      "/users/scouras/code/scouras",
      "/users/scouras/code/lyse",
  } else { 
    push @INC, 
      "/users/scouras/public",
      "/users/scouras/lyse",
  }
}

use warnings;
use strict;
use Data::Dumper;
use Utility;


####################################################################
#                                              LOAD ANALYSIS MODULES
####################################################################

use IQ;
use Ilmm;
use Job;
use BATCH;
use BATCH_10PS;
use BUTCHER;
use CONGENEAL;
use CONTACT;
use DSSP;
use FDSA;
use FLEX;
use MCGEO;
use PERIODIC;
use PHIPSI;
use RADGEE;
use RMSD;
use SASA;
use VCONT;

#use Lyse::SASA;

my %CONFIG = (
  run               =>                 1,
  plot              =>                 1,
  plot_only         =>                 0,
  reverse_groups    =>                 0,
  queue             =>        'analysis',
  leniency          =>              5000, # picoseconds
  leniency_time     =>                 5, # one day
  min_time          =>              5000, # picoseconds
  aggregate_groups  =>                 1,
  aggregate_sims    =>                 1,
  validate          =>                 1,
  cmddir            =>  'analysis_files',
  development       =>      $DEVELOPMENT,
);
my @CONFIG = ();
my %OPERATIONS = ();
my @ANALYSES = ();
my %ANALYSES = ();

$ANALYSES{'BATCH'     } = Lyse::BATCH     ->New();
$ANALYSES{'BATCH_10PS'} = Lyse::BATCH_10PS->New();
$ANALYSES{'BUTCHER'   } = Lyse::BUTCHER   ->New();
$ANALYSES{'CONGENEAL' } = Lyse::CONGENEAL ->New();
$ANALYSES{'CONTACT'   } = Lyse::CONTACT   ->New();
$ANALYSES{'DSSP'      } = Lyse::DSSP      ->New();
$ANALYSES{'FDSA'      } = Lyse::FDSA      ->New();
$ANALYSES{'FLEX'      } = Lyse::FLEX      ->New();
$ANALYSES{'MCGEO'     } = Lyse::MCGEO     ->New();
$ANALYSES{'PERIODIC'  } = Lyse::PERIODIC  ->New();
$ANALYSES{'PHIPSI'    } = Lyse::PHIPSI    ->New();
$ANALYSES{'RADGEE'    } = Lyse::RADGEE    ->New();
$ANALYSES{'RMSD'      } = Lyse::RMSD      ->New();
$ANALYSES{'SASA'      } = Lyse::SASA      ->New();
$ANALYSES{'VCONT'     } = Lyse::VCONT     ->New();




####################################################################
#                                                      CONFIGURATION
####################################################################




################################################ PRINT CONFIGURATION
print "lyse\n"
    . "by Alex Scouras <scouras\@u.washington.edu>\n"
    . "created 30 June 2008\n"
    . "Version Information\n"
    . "  Revision: $REVISION\n"
    . "  Author:   $AUTHOR\n"
    . "  Revised:  $CHECKED_IN\n"
    . "Current Execution\n"
    . "  User:     $USER\n"
    . "  Host:     $HOST\n"
    . "  Time:     $TIME\n"
    . "  CWD:      $PWD\n"
    . "\n\n";
    ;
 


################################################# PARSE COMMAND LINE

# Usage:
sub Usage {
  die "usage: $0 [-full] [-<analysis>] <configuration file> <simulation set>\n"
#    . "  -full: perform all analyses\n"
#    . "  -<analysis>: perform selected analysis (can be used multiple times)\n"
    . " <configuration files>: user's parameters for analysis\n"
    . " <simulation sets>: lists of simulations to analyze\n"
    . "-plotonly: only plot existing data, don't run or validate it\n"
    . "-noplot: queue analyses, but do not wait to plot them\n"
    . "-validate: only run the initial validation of mdc files\n"
    ;
}

my $DEFAULT_CONF = "/users/$USER/lyse.conf";
my $DEFAULT_LIST = "/users/$USER/analysis/lyse.list";
my @FILES = ();

foreach my $arg (@ARGV) {

  ##### --var=val
  if ( $arg =~ /^--(\w+)=(\w+)$/ ) {
    # none at this time

  ##### -flags
  } elsif ( $arg =~ /^-(\w+)$/ ) { 
    if ( $arg eq '-plotonly'      ) { $CONFIG{'plot_only'      } = 1; next; }
    if ( $arg eq '-strictplot'    ) { $CONFIG{'strict_plot'    } = 1; next; }
    if ( $arg eq '-noplot'        ) { $CONFIG{'plot'           } = 0; next; }
    if ( $arg eq '-validateonly'  ) { $CONFIG{'validateonly'   } = 1; next; }
    if ( $arg eq '-aggregateonly' ) { $CONFIG{'aggregateonly'  } = 1; next; }
    if ( $arg eq '-reverse'       ) { $CONFIG{'reverse_groups' } = 1; next; }
    if ( $arg eq '-rewind'        ) { $CONFIG{'rewind'         } = 1; next; }
    #if ( $arg eq '-novalidate'    ) { $CONFIG{'validate'       } = 0; next; }

  ##### files
  } else { 
    push @FILES, $arg;
  }
}
$CONFIG{'strict_plot'} |= 0;
$CONFIG{'plot_only'  } |= $CONFIG{'strict_plot'};

#print "PLOTONLY: $CONFIG{'plot_only'}\n"
#    . "STRICT:   $CONFIG{'strict_plot'}\n";

if ( scalar @FILES == 0 ) { 
  push @FILES, $DEFAULT_CONF, $DEFAULT_LIST;
} elsif ( scalar @FILES == 1 ) { 
  push @FILES, $DEFAULT_CONF;
}


######################################################### READ FILES
# Files are raw Perl and typically contain configuration settings
# or simulation sets. They could of course contain anything, being 
# Perl, but we'll assume that's not the case.

print "########## Reading Data Files\n";

my @SIMULATIONS = ();
foreach my $file ( @FILES ) {

  print "Reading Data File: $file\n";

  my @INCLUDE;
  my @DEFAULT_INCLUDE;
  my @SIMS;

  if ( -e $file ) {
    open FILE, $file or die "Couldn't open file, '$file'. $!";
    my $contents = join '', (<FILE>);
    close FILE or die "Couldn't close file, '$file'. $!";

    eval $contents;
    push @SIMULATIONS, @SIMS;
    die $@ if $@;
  }

  # Include files (this syntax will probably screw it all up. :)
  push @FILES, @INCLUDE;
  push @FILES, @DEFAULT_INCLUDE if scalar @FILES <= 1;
}




######################################## INITIALIZE ANALYSIS MODULES

print "########## Initializing Modules\n";


# Initialize user modified analysis
foreach my $anal (@CONFIG) {
  my $name = $anal->{'analysis'};
  if ( not exists $ANALYSES{$name} ) { 
    printf "%-20s%s\n", $name, "unknown.";
    next;
  }
  if ( not $OPERATIONS{$name} ) { 
    #printf "%-20s%s\n", $name, "skipped.";
    next;
  }
  my $anal_init = $ANALYSES{$name}->Initialize({%CONFIG, %$anal});
  push @ANALYSES, $anal_init;
  printf "%-20s%-20s\%s\n", 
    $anal_init->{'title'}, 
    $anal_init->{'revision'}, 
    "initialized with user parameters.";
  $ANALYSES{$name}{'running'} = 1;
}

# Initialize default analyses
foreach my $name (keys %ANALYSES) { 
  my $anal = $ANALYSES{$name};
  next if $anal->{'running'};
  my $name = $anal->{'name'};
  if ( not $OPERATIONS{$anal->{'name'}} ) { 
    printf "%-20s%s\n", $name, "skipped";
    next;
  }
  my $anal_init = $ANALYSES{$name}->Initialize(\%CONFIG);
  push @ANALYSES, $anal_init;
  printf "%-20s%-20s\%s\n", 
    $anal_init->{'title'}, 
    $anal_init->{'revision'},
    "initialized with default parameters.";
  $ANALYSES{$anal->{'name'}}{'running'} = 1;
}



####################################################################
#                                                                   
#                                             LOOP SIMULATION GROUPS
#                                                                   
####################################################################

print "\n########## Analyzing Simulation Groups\n";

if ( $CONFIG{'reverse_groups'} ) { @SIMULATIONS = reverse @SIMULATIONS }

my @ALL_JOBS = ();

foreach my $SIM_i (0..$#SIMULATIONS) { 
  my $SIM = $SIMULATIONS[$SIM_i];
  next if $SIM->{'skip'};
  my $sim_dir = $SIM->{'dir'};

  printf "\n##### Group %3i/%3i: \%s\n"
         . "##### Dir: \%s\n",
            $SIM_i + 1,
            scalar @SIMULATIONS,
            $SIM->{'title'},
            $SIM->{'dir'},
            ;

  ########## Go to directory if possible
  if ( not -e $sim_dir ) { 
    print "!!!!! Simulation group directory doesn't exist.\n";
    $SIM->{'skip'} = 1;
    next;
  }
  
  if ( not chdir $sim_dir ) {
    print "!!!!! Couldn't chdir to sim dir '$sim_dir'. $!";
    $SIM->{'skip'} = 1;
    next;
  }

  ########## Find subdirectories
  my @sub_dirs = grep { /^\d+$/ and -d } glob ( "[0-9]*" );
  if ( $SIM->{'subdirs'} ) { 
    @sub_dirs = Intersection(\@sub_dirs, $SIM->{'subdirs'});
  }
  $SIM->{'subdirs'} = \@sub_dirs;
  
  print "##### SubDirs: " . (join ', ', @sub_dirs) . "\n";
  my $num_dirs = scalar @sub_dirs;

  if ( not $num_dirs ) { 
    print "!!!!! No subdirs found. Skipping to next sim group.\n";
    next;
  }


####################################################################
#                                                   LOOP SIMULATIONS
####################################################################
  
  foreach my $sub_dir ( @sub_dirs ) { 

    print "===== SubDir $sub_dir\n";
    
    ########## CHDIR to sub directory
    if ( not chdir "$sim_dir/$sub_dir" ) { 
      print "!!! Couldn't chdir to directory.  Skipping\n";
      next;
    }

    ########## Load ILMM data
    my $ILMM = Ilmm::Load ( "$sim_dir/$sub_dir" );
    if ( not $ILMM ) {
      print "!!!!! Couldn't load Ilmm data.  Skipping.\n";
      next;
    }

    if ( $CONFIG{'validateonly'} ) { 
      print "***** Only validating mdc files\n";
      next;
    }

    if ( $ILMM->{'status'} eq 'prepped') { 
      print "***** Simulation is prepped but not run\n";
      next;
    }
    
    if ( $ILMM->{'status'} ne 'simulated' ) {
      print "***** Simulation has not been run.  Has status $ILMM->{'status'}.\n";;
      next;
    }
    
    my $SUBDIR = $SIM->{'subdir'}{$sub_dir} = {};
    $SUBDIR->{'ilmm'   } = $ILMM;
    $SUBDIR->{'regions'} = [];
    $SUBDIR->{'jobs'   } = [];
    
    print "===== Time:    $ILMM->{'total_time'} ps\n"
        . "===== Structs: $ILMM->{'total_structs'}\n";

    if ( $ILMM->{'total_time'} < $CONFIG{'min_time'} ) { 
      print "***** Simulation is too short to analyze, skipping.\n"
          . "***** Set \$CONFIG{'min_time'} to decrease threshold (currently $CONFIG{'min_time'}).\n";
      next;
    }


#===================================================================
#                                           LOOP REGIONS AND PERIODS
#===================================================================

    # Structural regions
    my @REGIONS = ();

    # Time periods (the [undef,undef] period constitutes the whole simulation)
    my @PERIODS = ( undef );
    if ( exists $SIM->{'periods'} ) { 
      foreach my $period ( @{$SIM->{'periods'}}) { 
        my $start = $period->[0];
        my $end   = $period->[1];
        if ( $end > (($ILMM->{'total_time'}+1)/1000) ) { 
          print "..... Skipping period $start ns - $end ns because it exceeds the time of the simulation.\n";
          next;
        } else { 
          push @PERIODS, $period;
        }
      }
    }

    #====================== CREATE SYSTEM AND WHOLE MOLECULE REGIONS
    my @MOLECULE_NAMES      = @{$ILMM->{'molecule_names'}};
    my @MOLECULES_BY_NUMBER = @{$ILMM->{'molecules_by_number'}};
    my %MOLECULES           = %{$ILMM->{'molecules'}};


    foreach my $period ( @PERIODS ) {

      my $title_period = "";
      if ( defined $period ) { 
        $title_period .= " $period->[0]ns-$period->[1]ns";
      }

      ##### If the system is composed of multiple molecules, 
      ##### treat them separately

      #print "      Molecules " . scalar @MOLECULES . "\n";
      if ( @MOLECULE_NAMES != 1 ) { 
        
        # Whole system
        push @REGIONS, Lyse::Region::new( $SIM->{'title'}, $sub_dir, 'System'.$title_period, '*', 0, 1, $period, {} );
        $REGIONS[0]{'start_residue'} = $SIM->{'start_residue'} if exists $SIM->{'start_residue'};
        
        # Individual molecules
        foreach my $MOL (@MOLECULES_BY_NUMBER) {
          my $i = $MOL->{'index'};
          my $n = $MOL->{'mol'};
          $MOL->{'name'} = $MOL->{'mol'};
          my $title = "$i $n$title_period";
          my $select = $MOL->{'select'} || "$i:0-" . ($MOL->{'length'}-1);
          push @REGIONS, Lyse::Region::new( $SIM->{'title'}, $sub_dir, $title, $select, 1, 0, $period, $MOL );
          $REGIONS[-1]{'start_residue'} = $SIM->{'start_residue'} if exists $SIM->{'start_residue'};
        }
      } else { 
        push @REGIONS, Lyse::Region::new( $SIM->{'title'}, $sub_dir, 'System'.$title_period, '*', 1, 1, $period, $MOLECULES_BY_NUMBER[0] );
        $REGIONS[0]{'start_residue'} = $SIM->{'start_residue'} if exists $SIM->{'start_residue'};
      }

      #---------------------------------- CONVERT CONFIGURED REGIONS
      foreach my $reg ( @{$SIM->{'regions'}} ) {
        my $title = $reg->{'title'};
        my $select = $reg->{'selection'};
        if ( not $select ) { 
          $select = ($reg->{'index'})
               .":".($reg->{'start'}-$SIM->{'start_residue'})
               ."-".($reg->{'end'  }-$SIM->{'start_residue'});
        } 
        push @REGIONS, Lyse::Region::new( $SIM->{'title'}, $sub_dir, $title.$title_period, $select, 0, 0, $period, $reg );
        $REGIONS[-1]{'start_residue'} = $reg->{'start'} if $reg->{'start'};
        $REGIONS[-1]{'start_residue'} = $reg->{'start_residue'} if $reg->{'start_residue'};
      }
    }


    #=========================================== ANALYZE EACH REGION
    #print "----- Analyzing Regions\n";
    foreach my $REGION (@REGIONS) {

      print "----- Region: $REGION->{'title'}\n";



      if ( exists $ILMM->{'regions'}{$REGION->{'title'}} ) {
        die "There are two regions with the same name, '$REGION->{'name'}'."; 
      }
      $ILMM->{'regions'}{$REGION->{'title'}} = $REGION;
      push @{$SUBDIR->{'regions'}}, $REGION;

      # TODO: Push some of this decision making out here
      my $is_regional  = $REGION->{'system'};
      my $is_temporal  = $REGION->{'period'};
      my $is_molecular = $REGION->{'molecule'};

#-------------------------------------------------------------------
#                                                      LOOP ANALYSES
#-------------------------------------------------------------------

      my @jobs = ();
      foreach my $anal (@ANALYSES) {

        #print "Attempting analysis $anal\n";

        #---------- Determine if analysis is to be run
        my $restrict_title  = $anal->{'restrict_title'};
        my $restrict_dir    = $anal->{'restrict_dir'};
        my $restrict_region = $anal->{'restrict_regin'};

        #print "RESTRICT: $restrict_title\n" if $restrict_title;

        next if $restrict_title  and not $SIM   ->{'title'} =~ /$restrict_title/;
        next if $restrict_dir    and not $SIM   ->{'dir'  } =~ /$restrict_dir/;
        next if $restrict_region and not $REGION->{'title'} =~ /$restrict_region/;

        my @subjobs = $anal->Get_Jobs($ILMM, $REGION);
        foreach my $job ( @subjobs ) { 

          # Job had a problem in preparation
          if ( $job->{'status'}{'error'} ) { 
            Report ($job, "error in prep ($job->{'error'})");
            next;
          }

          # Job is complete
          if ( $job->{'status'}{'valid'} ) { 
            if ( not $anal->{'is_plotted'} ) { 
              $job->{'status'}{'complete'} = 1;
              Report ( $job, "job complete" );
              next;
            }
          
            my ( $plot_valid, $plot_message ) = $anal->Validate_Plot($job);
            if ( $plot_valid ) { 
              $job->{'status'}{'complete'} = 1;
              Report ($job, "job complete");
              next;
            } 
          }  
          
          # Job only needs plotting or we're in plot only mode
          if ( $job->{'status'}{'valid'} 
              or ($CONFIG{'plot_only'} and not $CONFIG{'strict_plot'}) ) { 

            if ( not $anal->{'is_plotted'} ) { 
              Report ($job, "incomplete, not plotted");
              next;
            }

            # not finished running, but had already been plotted
            my ( $plot_valid, $plot_message ) = $anal->Validate_Plot($job);
            if ( $plot_valid ) { 
              Report ($job, "incomplete but plotted");
              next;
            }
            
            # try plotting
            if ( $CONFIG{'plot'} ) { 
              ($plot_valid, $plot_message) = $anal->Plot_Job($job);
            } else { 
              $plot_valid = 0;
              $plot_message = "not plotting";
            }

            # worked, job now plotted
            if ( $plot_valid ) { 
              $job->{'status'}{'plot_status'} = $plot_message;
              Report ($job, "job complete");
              next;
            # plotting error
            } else { 
              if ( not $plot_message ) { $plot_message = "no reason given" }
              $job->{'status'}{'plot_status'} = $plot_message;
              if ( $plot_message eq 'not plotting' ) { Report ($job, "needs plotting") }
              else                                   { Report ($job, "error plotting ($plot_message)") }
              next;
            }
          } 

          # otherwise job hasn't been run yet.
          if ( $CONFIG{'plot_only'} ) { 
            Report ($job, "not run");
            next;
          }



          # Job needs to be queued for analysis
          if ( $job->{'runtype'} eq 'queue' ) {
            my $status = '';
            if ( $CONFIG{'run'} ) { 
              if ( Start_IQ_Job($job) ) {
                if ( $job->{'IQ'}{'preempted'} ) { 
                  $status = "prempted by job ($job->{'IQ'}{'id'})";
                } else { 
                  $status = "queued on $anal->{'queue'} with job id $job->{'IQ'}{'id'}"
                          . " ($job->{'status'}{'initial'})";
                }
              } else { 
                $status = "error in queue ($job->{'status'}{'error'})";
              }
            } else {
              $status = "would be queued ($job->{'status'}{'initial'})";
              $job->{'status'}{'skipped'} = 1;
            }
            Report ($job, $status);
            next;

          # Job will run on its own
          } else { 
            if ( $CONFIG{'run'} ) { 
              Report ($job, "is executing ($job->{'status'}{'initial'})");
              if ( not $job->Start() ) {
                Report ($job, "exited with error $job->{'status'}{'error'}");
                next;
              }
              $job->{'executed'} = 1;
            } else { 
              Report ($job, "was prepared but not being run ($job->{'status'}{'initial'})" );
              $job->{'status'}{'skipped'} = 1;
            }
          }
        }
        push @jobs, @subjobs;
      }

      $REGION->{'jobs'} = \@jobs;
      push @ALL_JOBS, @jobs;
      push @{$SUBDIR->{'jobs'}}, @jobs;

    }
    #exit;
  }
}

#-------------------------------------- VERIFY AND PLOT ANALYSES
# Continually poll whether the analyses are complete, and 
# verify their completeness when the jobs are finished.  Then
# plot them.

if ( not $CONFIG{'plot_only'} ) { 

my $COMPLETE = 0;
my $NEW_COMPLETE = 0;
my $POLL_WAIT = 1;
my $last_dot = 0;
my @last_incomplete = ();

# Jobs to try before restarting polls.
my $MAX_WAITING = 20;


my $MAX_PASSES    = $CONFIG{'max_passes'   } || 3;  # 3 Complete Passes
my $MAX_PASS_TIME = $CONFIG{'max_pass_time'} || 1 * 60 * 60; # 1 Hour
my $REPORT_TIME   = $CONFIG{'report_time'  } || 5 * 60; # 5 minutes
my $passes_complete = 0;
my $pass_start_time = time();
my $report_time     = time();

print "########## POLLING JOB COMPLETENESS\n";

my @no_wait = grep { not $_->{'status'}{'complete' } }
              grep { not $_->{'status'}{'executed' } }
              grep { not $_->{'status'}{'error'    } }
              grep { not $_->{'status'}{'skipped'  } }
              grep { not $_->{'anal'}{'wait_to_finish'} } 
                @ALL_JOBS;
foreach my $job (@no_wait) {
  Report ( $job, "not waiting for completion" );
}

while ( not $COMPLETE ) { 
  $COMPLETE = 1;

  my @incomplete = grep { not $_->{'status'}{'complete'} }
                   grep { not $_->{'status'}{'error'   } }
                   grep { not $_->{'status'}{'skipped' } }
                   grep { $_->{'anal'}{'wait_to_finish'} and not $_->{'status'}{'executed'} }
                    @ALL_JOBS;

  last if not @incomplete;

  print "\n### Jobs remaining: " . scalar @incomplete . "\n" 
    if ( (scalar @last_incomplete) != (scalar @incomplete) );

  my $waiting = 0;
  my $found_job = 0;

  if ( ($report_time + $REPORT_TIME) < time ) { 
    print "\n###   Still waiting on these jobs:\n";
    foreach my $job ( @incomplete ) { 
      Report ( $job, 'Queued' );
      $report_time = time;
    }
  }
  
  foreach my $job (@incomplete) {

    last if $found_job and ($waiting >= $MAX_WAITING);

    #print Dumper($job);

    next if $job->{'status'}{'complete'};
    next if $job->{'status'}{'error'   };
    my $anal = $job->{'anal'};
    
    # Check if job has completed since last polling.
    if ( not $job->{'status'}{'executed'} ) { $job->Refresh() }

    # Job not done yet
    if ( not $job->{'status'}{'executed'} ) { 
      print '.';
      $last_dot = 1;
      $COMPLETE = 0;
      $waiting++;
      next;
    }
    $waiting = 0;
    $found_job = 1;
    $passes_complete = 0;
    $pass_start_time = time;
    $report_time = time;

    if ( $waiting > $MAX_WAITING ) { $MAX_WAITING = $waiting*2; }
    
    if ( $last_dot ) { 
      print "\n";
      $last_dot = 0;
    }

    # Detect errors in execution
    if ( $job->{'status'}{'error'} ) { 
      Report ( $job, "execution error ($job->{'status'}{'error'})" );
      next;
    }

   
    #............................................... VERIFY ANALYSES
    # Job has finished, validate data.
    my ($valid, $error) = $anal->Validate_Job($job);
    if ( not $valid ) { 
      #print "  Analysis has completed with error: $error\n";
      $job->{'status'}{'error'} = $error;
      Report ( $job, "error durring analysis ($error)" );
      next;
    } else {
      $job->{'status'}{'valid'} = 1;
    }
    
    #................................................. PLOT ANALYSES
    if ( not $anal->{'is_plotted'} ) { 
      Report($job, 'analysis complete, not plotted');
      $job->{'status'}{'complete'} = 1;
      next;
    }

    ($valid, $error) = $anal->Validate_Plot($job);
    #if ( $error =~ /overwrite/ ) { $valid = 1 }
    if ($valid) { 
      Report($job, 'already plotted');
      $job->{'status'}{'complete'} = 1;
      next;
    } 
    $job->{'status'}{'plot'} = $error;

    if ( $CONFIG{'plot'} ) { 
      ($valid, $error) = $anal->Plot_Job($job);
    } else { 
      $valid = 1;
    }
    if ( $job->{'status'}{'plotted'} ) { 
      Report ($job, "plotted ($job->{'status'}{'plot'})");
      $job->{'status'}{'complete'} = 1;
    } else { 
      if ( not $error ) { $error = "unknown error" }
      Report ($job, "error durring plotting ($error)");
      $job->{'status'}{'error'} = $error;
    }
  }
  @last_incomplete = @incomplete;
  $passes_complete++;

  
  if ( $passes_complete >= $MAX_PASSES
    and ($pass_start_time + $MAX_PASS_TIME) < time ) { 
    print "We've made $passes_complete passes through the jobs\n"
        . "and waited for over $MAX_PASS_TIME seconds since the last job finished.\n"
        . "Probably the remaining jobs are broken somehow, you might check on them:\n"
        ;
    foreach my $job ( @incomplete ) { 
      Report($job, "never finished ($job->{'IQ'}{'id'})");
    }
    $COMPLETE = 1;
  }

  sleep($POLL_WAIT);

}

} #/END IF $CONFIG{'plot_only'}

####################################################################
#                                                                   
#                                                    AGGREGATE PLOTS
#                                                                   
####################################################################

print "\n########## Aggregating Plots\n";

if ( $CONFIG{'repository'} ) { 
  if ( ( not -e $CONFIG{'repository'} )
    or ( not -d $CONFIG{'repository'} ) ) {
    die "Missing image repository, '$CONFIG{'repository'}'.";
  }
  print "Repository: $CONFIG{'repository'}\n";
}

foreach my $SIM_i ( 0..$#SIMULATIONS ) { 

  my $SIM = $SIMULATIONS[$SIM_i];
  next if $SIM->{'skip'};
  my $sim_dir = $SIM->{'dir'};

  printf "\n##### Group %3i/%3i: \%s\n"
         . "##### Dir: \%s\n",
            $SIM_i + 1,
            scalar @SIMULATIONS,
            $SIM->{'title'},
            $SIM->{'dir'},
            ;

  my $image_group = "$sim_dir/"
                  . "group_-_"
                  . (lc Utility::Clean_Filename($SIM->{'title'}))
                  . ".png";
  my $time_image_group;
  if ( -e $image_group ) { $time_image_group = -M $image_group }
  else                   { $time_image_group =               0 }

  my $needs_aggregation_group = $time_image_group ? 0 : 1;
  if ( $CONFIG{'reaggregate_plots'} ) { $needs_aggregation_group = 1 }
  my @existing_sims = ();

  foreach my $subdir ( @{$SIM->{"subdirs"}} ) { 

    print "===== SubDir $subdir\n";

    my $SUBDIR = $SIM->{'subdir'}{$subdir};
    
    # Get data on the simulation aggregate image
    my $image_sim = "$sim_dir/$subdir/"
                  . "sim_-_"
                  . (lc Utility::Clean_Filename($SIM->{'title'}))
                  . "_$subdir"
                  . ".png";
    my $time_image_sim;
    if ( -e $image_sim ) { $time_image_sim = -M $image_sim }
    else                 { $time_image_sim =             0 }

    #my $needs_aggregation_sim = 1;
    my $needs_aggregation_sim = $time_image_sim ? 0 : 1;
    if ( $CONFIG{'reaggregate_plots'} ) { $needs_aggregation_sim = 1 }
    my @existing_jobs = ();
    
    foreach my $job ( @{$SUBDIR->{'jobs'}} ) { 
      
      my $targetdir = "$CONFIG{'repository'}/$job->{'type'}";
      $targetdir =~ s/\s/_/g;
      $targetdir = lc $targetdir;
      my $targetdata = "$targetdir\_data";
      my $targetimage = "$targetdir\_image";
      foreach my $t ( $targetdata, $targetimage ) { 
        if ( not -e $t ) { 
          try_command ( "mkdir -p $t" )
            or die "Couldn't make repository directory $t. $!";
        }
      }

      # Process data files
      foreach my $data_job ( @{$job->{'data_files'}} ) { 
        #print "$image_job\n";
        next if not -e $data_job;
        
        # Copy to repository
        if ( $CONFIG{'repository'} ) { 
          my $c = "rsync -a \"$data_job\" $targetdata";
          #my $c = "rsync -a \"$data_job\" $CONFIG{'repository'}";
          #print "Copying $data_job to repository\n$c\n";
          print `$c`;
        } else {
          #print "NOT copying $data_job to repository\n";
        }
      }


      # Process individual simulations
      foreach my $image_job ( @{$job->{'images'}} ) { 
        #print "$image_job\n";
        next if not -e $image_job;
        foreach my $filter ( @{$CONFIG{'image_list'}} ) { 
          my $match   = $filter->{'match'};
          my $include = $filter->{'include'};
          if ( $image_job =~ /$match/i ) { 
            if ( $match ) { 
              if ( $include ) { 
                #print "Including job $image_job based on filter $match ($include)\n";
                push @existing_jobs, $image_job;    
              } else { 
                #print "Skipping job $image_job based on filter $match ($include)\n";
                last;
              }
            } else { 
              #print "Job $image_job does not match filter $match ($include)\n";
            }
          }
        }
        if ( -M $image_job > $time_image_sim ) { 
          $needs_aggregation_sim = 1;
        }
        
        # Copy to repository
        if ( $CONFIG{'repository'} ) { 
          my $c = "rsync -a \"$image_job\" $targetimage";
          #print "Copying $image_job to repository\n$c\n";
          print `$c`;
        } else {
          #print "NOT copying $image_job to repository\n";
        }
      }
    }
    next if not @existing_jobs;

    # Aggregate images from all jobs in a simulation
    if ( $CONFIG{'aggregate_sims'} and $needs_aggregation_sim ) { 
      my $agg_sim_command = "convert "
        . (join ' ', map { "\"$_\"" } @existing_jobs)
        . " -append $image_sim "
        . "2>&1"
        ;
      #print "$agg_sim_command\n";
      my $result = `$agg_sim_command`;

      # Copy to repository
      if ( -e $image_sim and $CONFIG{'repository'} ) { 
        `rsync -a \"$image_sim\" $CONFIG{'repository'}`;
        push @existing_sims, $image_sim;
      }  
    }
  }
   
  # Aggregate images from all simulations in a group
  if ( $CONFIG{'aggregate_groups'} and $needs_aggregation_group ) { 
    my $agg_group_command = "convert "
      . (join ' ', map { "\"$_\"" } @existing_sims)
      . " +append $image_group "
      . "2>&1"
      ;
    #print "$agg_group_command\n";
    my $result = `$agg_group_command`;

    # Copy to repository
    if ( -e $image_group and $CONFIG{'repository'} ) { 
      `cp \"$image_group\" $CONFIG{'repository'}`;
    }  
  }
}




####################################################################
#                                                                   
#                                                        SUBROUTINES
#                                                                   
####################################################################


######## REPORT

sub Report {
  my $job = $_[0];
  my $status = $_[1];
  
  printf "%-30s :: %-2u :: %-20s :: %-20s :: \%s\n",
    $job->{'region'}{'sim_group'},
    $job->{'region'}{'sim_run'},
    $job->{'region'}{'title'},
    "$job->{'type'}",
    $status,
    ;
}



########## START IQ JOB
# Add an analyze_custom command and link the proper subroutines.

sub Start_IQ_Job {
  my $job = $_[0];

  return if exists $job->{'IQ'};

  my $dep_job = $job->{'dependency'};
  my $dependency = 0;

  while ( $dep_job ) { 
    if ( not $dep_job->{'status'}{'valid'} ) {
      if ( not $dep_job->{'IQ'} 
        or not $dep_job->{'IQ'}{'id'} ) { 
        die "Job was dependent on $dep_job->{'title'} which has not been started.";
      } else { 
        $dependency = $dep_job->{'IQ'}{'id'};
        last;
      }
    } else { 
      if ( $dep_job->{'dependency'} ) { 
        $dep_job = $dep_job->{'dependency'};
      } else { 
        $dep_job = 0;
      }
    }
  }
  
  my $IQ = IQ::new_analyze_custom ( 
    $job->{'protein'},      # protein (.is file prefix)
    $job->{'file_name'},    # .i file title
    $job->{'resolution'},   # resolution
    $job->{'line'},         # actual analysis line

    { datadir     => (exists $job->{'datadir'} ? $job->{'datadir'} : $job->{'dir'}),
      targetdir   => (exists $job->{'targetdir'} ? $job->{'targetdir'} : $job->{'dir'}), 
      cmddir      => $CONFIG{'cmddir'},
      queue       => $job->{'queue'}, 
      dependency  => $dependency, 
      ilmm_title  => $job->{'ilmm_title'},   
      library     => $job->{'library'}, 
      priority    => ($job->{'anal'}{'priority'} || ($job->{'anal'}{'wait_to_finish'} ? 0 : 0)),
      period      => $job->{'period'},
      threads     => ($job->{'anal'}{'threads'} || 1), 
      extra       => $job->{'extra'},
    },
  );
  $job->{'IQ'} = $IQ;
  $job->{'refresh'} = \&Refresh_IQ_Job;


  #print $job->{'IQ'}{'command'} . "\n";
  $IQ->{'preempted'} = 0;
  if ( not $IQ->Start() ) { 
    $job->{'status'}{'error'} = $IQ->{'output'};
    return 0;
  } elsif ( $IQ->{'preempted'} ) { 
    $job->{'status'}{'queued'} = 1;
    return 1;
  } else {
    $job->{'status'}{'queued'} = 1;
    return 1;
  }
  return 1;
}

sub Refresh_IQ_Job {
  my $job = $_[0];
  my $IQ = $job->{'IQ'};

  my ( $status, $message ) = $IQ->Status();
  if ( $status eq 'error'     ) { 
    $job->{'status'}{'error'   } = $message;
    return ($status, $message);
  }
  if ( $status eq 'finished'  ) { 
    $job->{'status'}{'executed'} = 1;
    return ($status, $message);
    }
}

###################################################### DISCERN DEATH
# Helper to subroutine try_command.  This sub processes the return
# value of executed programs.


sub discern_death {
  my $program = $_[0];
  my $value = $_[1];
  
  if ($value == -1) {
	  print "!!!!! $program  Failed to execute: $!\n";
  }
  elsif ($value & 127) {
	  printf "!!!!! $program  Child died with signal %d, %s coredump\n",
    ($value & 127),  ($value & 128) ? 'with' : 'without';
  }
  else {
  	printf "!!!!! $program  Child exited with value %d\n", $value >> 8;
  }

}


######################################################## TRY COMMAND
# Attempts to execute a command (if in RUN mode).  Processes any
# return values.  Prints progress.

sub try_command {
  my $command   = $_[0];
  
  print "$command\n";
  my $result = system ( $command );
  #print "    $command\n" if not $RUN;
  if ( $result ) { 
    discern_death ( "command '$command' died.", $? ); 
    return 0;
  } else { 
    return 1;
  }
}

