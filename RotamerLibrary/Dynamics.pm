package RotLib::Dynamics;
BEGIN{
  push @INC,
            "/users/scouras/code",
            "/users/scouras/code/scouras",
            "/Users/lexicon/lab/code",
            "/Users/lexicon/lab/code/scouras",
            "/net/programs/perl",
            "/net/programs/perl/lib/perl5/site_perl/5.8.5/i386-linux-thread-multi",
}

#use 5.008006;
use strict;
use warnings;
use Utility qw(:all);
use Data::Dumper;
use PerlIO::gzip;

require Exporter;

our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use RotLib ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	
) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw(
	
);


# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.1.1.1 $'          =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/03/25 18:32:30 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;

our %PREFIXES_DYN = (
 

);


our %CONFIG_DYN = (

  decay_cap => 1000,
  logarithms => [ 2, 10 ],
  files => { 
    # Curve Fitting Program
    curve_fit_file => "code/scouras/curve_fit",
    
    # OUTPUT
    dynamics_arrays       => 'dynamics_array',
    dynamics_values       => 'dynamics_values',
    dihedral_transitions  => 'transitions.dihedral.dat',  
    rotamer_transitions   => 'transitions.rotamer.dat',
  },

  bin_width => 5,
  periods => [1, 10, 100],

  curve_fit_formulas => [""], # unused at this time
  metadata  => [qw(total_rotamers rotamer_names angle_names residue res_name )],
);







######################################################### INITIALIZE

sub Initialize {

  my $class     = $_[0];
  my $CONFIG    = $_[1];
  my $AA        = $_[2];
  my $PROTEINS  = $_[3];

  my $DYN = {%CONFIG_DYN};
  bless $DYN, $class;
  

  $DYN->{'main'} = $CONFIG;
  $DYN->{'AA'  } = $AA;
  $DYN->{'files'}{'curve_fit'} = $CONFIG->{'home_dir'} 
                               . "/" 
                               . $DYN->{'files'}{'curve_fit_file'};
  $DYN->{'bin_count'} = POSIX::ceil ( 360 / $CONFIG_DYN{'bin_width'} );
  
  return $DYN;

};

sub Initialize_Aggregator {

  my $self = $_[0];
  my $agg  = $_[1] || {};

  $agg->{'wait_counts'} = {};
  $agg->{'wait_times' } = {};
#  if ( not exists $agg->{'wait_counts'} or not $agg->{'wait_counts'}) { 
#    $agg->{'wait_counts'} = {};
#  } else {
#    for my $angle ( keys %{$agg->{'wait_counts'}} ) {
#      for my $key ( keys %{$agg->{'wait_counts'}{$angle}} ) {
#        for my $i ( 0..$#{$agg->{'wait_counts'}{$angle}{$key}} ) {
#          if ( defined $agg->{'wait_counts'}{$angle}{$key}[$i] ) {
#            $agg->{'wait_counts'}{$angle}{$key}[$i] = 0;
#          }
#        }
#      }
#    }
#  }
  $agg->{'mean'         } = {};
  $agg->{'stddev'       } = {};
  $agg->{'total'        } = {};
  $agg->{'distribution' } = {};
  $agg->{'changes'      } = {};
  foreach my $log ( @{$self->{'logarithms'}} ) {
    $agg->{"log$log\_counts"} = {};
    $agg->{"log$log\_times" } = {};
  }
  
  $agg->{'trans'        } = {};
  
  $agg->{'populated'} = 0;
  $agg->{'normalized'} = 0;
 

  return $agg;


}

########################################################### ANALYSIS

sub Analyze {

  my $self = $_[0];
  my $data = $_[1];
  my $RES  = $_[2];

  my $rotamer_names = $RES->{'rotamer_names'};
  my $angle_names   = $RES->{'angle_names'};
  my $total_rotamers = $RES->{'total_rotamers'};


  my %headers = %{$RES->{'headers'}};
  my $i_time = $headers{'time'};
  
  my $line;
  my ( $time );
  my ( %dihedrals, %rotamers, %last_rotamers, %last_times, %last_dihedrals );
  my ( $d_time );
  my $bin_count = $self->{'bin_count'};
  my $bin_width = $self->{'bin_width'};


  my $wait_counts = $data->{'wait_counts'};
  my $wait_times  = $data->{'wait_times'};
  my $trans = $data->{'trans'};
  

  ##### Add Legends to Transition Data

  for my $angle ( @$angle_names ) { 
    $trans->{'dihedrals'}{'legend'}{$angle} = [map { $_ * $bin_width } 0..$bin_count-1];
  }
  $trans->{'dihedrals'}{'angles'} = $angle_names;
  $trans->{'dihedrals'}{'file'} = $self->{'files'}{'dihedral_transitions'};

  for my $angle ( @$rotamer_names ) {
    my $minors = $RES->{'residue'}{'dihedrals'}{$angle}{'minors'};
    my %lookup = map { $minors->[$_]{'number'} => $minors->[$_]{'conformation'} } 0..$#{$minors};
    $trans->{'rotamers'}{'legend'}{$angle} = [ map { $lookup{$_} } sort keys %lookup ];
    $trans->{'rotamers'}{'lookup'}{$angle} = { map { $minors->[$_]{'conformation'} => $minors->[$_]{'number'}-1 } 0..$#{$minors} } ;
  }
  $trans->{'rotamers'}{'legend'}{'major'} = [1..$total_rotamers];
#  $trans->{'rotamers'}{'legend'}{'major'} = 
#    [map { join ',', @{$RES->{'residue'}{'major_to_minor'}[$_]} } 0..$total_rotamers-1 ];
  $trans->{'rotamers'}{'lookup'}{'major'} = { map { $_ => $_ } 0..$total_rotamers-1 };
  $trans->{'rotamers'}{'angles'} = ['major', @$rotamer_names];
  $trans->{'rotamers'}{'file'} = $self->{'files'}{'rotamer_transitions'};
  my $lookup = $trans->{'rotamers'}{'lookup'};


  ##### LOOP OVER EACH TIMEPOINT
  foreach  my $t ( 0..$RES->{'timepoints'}-1 )  {
    # Get data for this timepoint
    $line = $RES->{'data'}[$t];
    $time = $line->[$i_time];

    %rotamers = map { $_ => $line->[$headers{"rotamer_$_"}] } @$rotamer_names, 'major';
    %dihedrals   = map { $_ => $line->[$headers{$_          }] } @$angle_names;
    
    # If at first timepoint, set it as the previous timepoint
    if ( not defined $last_times{'major'} ) {
      %last_rotamers = %rotamers;
      %last_dihedrals = %dihedrals;
      %last_times = map { $_ => $time } ( @$rotamer_names, 'major' );
      next;
    }


    # Analyze Dihedral Angles
    # TODO: Are we sure about this calculation?
    my ($i, $j);
    foreach my $angle ( @$angle_names ) {
      $i = (sprintf "%.0f", $last_dihedrals{$angle} / $bin_width);
      $j = (sprintf "%.0f", $dihedrals     {$angle} / $bin_width);
      $trans->{'dihedrals'}{'data'}{$angle}[$i][$j]++;
    }

    # Analyze Rotamers
    foreach my $angle ( @$rotamer_names, 'major' ) {
      if ( not exists $rotamers{$angle} or not defined $rotamers{$angle}) {
        die "Dynamics::Analyze: Missing data for residue $RES->{'res_name'} angle $angle.\n";
      }

      ### Measure Rotamer Transitions
      #print "LAST $angle: $last_rotamers{$angle}\n";
      #print "TRANS $angle $rotamers{$angle}\n";
      $trans->{'rotamers'}{'data'}
              {$angle}
              [$lookup->{$angle}{$last_rotamers{$angle}}]
              [$lookup->{$angle}{     $rotamers{$angle}}]++;

      ### Calculate Rotamer Waiting Times
      # check each rotameric dihedral angle to see if it has changed...
      # or if we're at the last timepoint.
      if ( ( $rotamers{$angle} ne $last_rotamers{$angle} )
        or ( $t == ($RES->{'timepoints'} - 1) ) ) { 
        $d_time = POSIX::floor($time - $last_times{$angle});
        $wait_counts->{$angle}{'all'                 }[$d_time] ++;
        $wait_counts->{$angle}{$last_rotamers{$angle}}[$d_time] ++;
        $last_times{$angle} = $time;

        #print "$angle\t$rotamers{$angle}\t$last_rotamers{$angle}\t$d_time\n";
      }
    }
    %last_rotamers = %rotamers;
    %last_dihedrals = %dihedrals;
  }


  ##### COPY WAIT_COUNTS TO WAIT_TIME AND NORMALIZE BY TIME
  foreach my $angle ( @$rotamer_names, 'major' ) { 
    foreach my $rotamer ( keys %{$wait_counts->{$angle}} ) { 
      # Initialize wait_times slot for a given angle and rotamer.
      $wait_times->{$angle}{$rotamer} = [];
      # Copy wait_counts to wait_times
      Combine_Histograms($wait_times->{$angle}{$rotamer}, $wait_counts->{$angle}{$rotamer});
      # Normalize wait_times to time
      Normalize_Histogram_to_Population ( $wait_times->{$angle}{$rotamer} );
    }
  }

  $self->Copy_Metadata ( $data, $RES );
  $data->{'populated'} = 1;
  return $data;
}



sub Analyze_Secondary {

  my $self = $_[0];
  my $data = $_[1];

  if ( not $data->{'normalized'} ) { $self->Normalize ( $data ); } 

  my $rotamer_names  = $data->{'rotamer_names'};
  my $total_rotamers = $data->{'total_rotamers'};

  # Loop over all angles (including "major" virtual angle)
  foreach my $angle ( 'major', @$rotamer_names ) {
    foreach my $rotamer ( keys %{$data->{'wait_counts'}{$angle}} ) {
      my $wait_counts = $data->{'wait_counts'}{$angle}{$rotamer};
      my $wait_times  = $data->{'wait_times' }{$angle}{$rotamer};
      
      # Logarithms of histograms
      foreach my $log ( @{$self->{'logarithms'}} ) {
        $data->{"log$log\_counts"}{$angle}{$rotamer}
          = Make_LogX_Histogram ( $wait_counts, $log );
        $data->{"log$log\_times"}{$angle}{$rotamer}
          = Make_LogX_Histogram ( $wait_times, $log );
      }

      # Mean, Standard Deviation, Changes, and Total
      ( $data->{'mean_counts'   }{$angle}{$rotamer}, $data->{'stddev_counts'}{$angle}{$rotamer}, 
        $data->{'changes_counts'}{$angle}{$rotamer}, $data->{'total_counts' }{$angle}{$rotamer} ) 
          = Hist_Mean_and_Stddev ( $wait_counts );
      ( $data->{'mean_times'   }{$angle}{$rotamer}, $data->{'stddev_times'}{$angle}{$rotamer}, 
        $data->{'changes_times'}{$angle}{$rotamer}, $data->{'total_times' }{$angle}{$rotamer} ) 
          = Hist_Mean_and_Stddev ( $wait_times );
      

      # Curve Fittings
      # We are no longer doing exponential decay fitting hre, and therefore haven't added 
      # wait_times to the curve fitting.  Curve fitting is done in post processing now.
      #my $max_cap = Min ( $self->{'decay_cap'}, $#$wait_counts );
      #my $decay_command = "echo '"
      #                  . (join "\n", map { "$_\t$wait_counts->[$_]" } 0..$max_cap )
      #                  . "' | $self->{'files'}{'curve_fit'}"
      #                  ;
      #
      #                  #$data->{'decay'}{$angle}{$rotamer} = (split /\s+/, `$decay_command`)[0];
      $data->{'decay'}{$angle}{$rotamer} = 0;
    }
  }
}






########################################################## AGGREGATE
sub Aggregate {
  my $self = $_[0];
  my $agg  = $_[1];
  my $data = $_[2];

  if ( $agg->{'normalized'} ) { 
    die "Dynamics: The aggregators has already been normalized, so you cannot aggregate more data to it.\n"; }

  if ( not $data->{'normalized'} ) { $self->Normalize ( $data ); } 
  
  my $rotamer_names = $data->{'rotamer_names'};
  my $angle_names = $data->{'angle_names'};

  # Copy metadata to aggregate datastructure
  $agg->{'trans'}{'dihedrals'}{'legend'} = $data->{'trans'}{'dihedrals'}{'legend'};
  $agg->{'trans'}{'dihedrals'}{'angles'} = $data->{'trans'}{'dihedrals'}{'angles'};
  $agg->{'trans'}{'dihedrals'}{'file'  } = $data->{'trans'}{'dihedrals'}{'file'  };
  $agg->{'trans'}{'rotamers' }{'legend'} = $data->{'trans'}{'rotamers' }{'legend'};
  $agg->{'trans'}{'rotamers' }{'angles'} = $data->{'trans'}{'rotamers' }{'angles'};
  $agg->{'trans'}{'rotamers' }{'file'  } = $data->{'trans'}{'rotamers' }{'file'  };
  $agg->{'trans'}{'rotamers' }{'lookup'} = $data->{'trans'}{'rotamers' }{'lookup'};

  # Add dihedral transition data to aggregate histogram
  foreach my $angle ( @$angle_names ) {
    if ( not defined $agg->{'trans'}{'dihedrals'}{'data'}{$angle} ) { 
      $agg->{'trans'}{'dihedrals'}{'data'}{$angle} = [];
    }
    Combine_Histograms_2D ( $agg->{'trans'}{'dihedrals'}{'data'}{$angle}, $data->{'trans'}{'dihedrals'}{'data'}{$angle} );
  }

  # Add rotamer transition data, wait_counts, and wait_times to aggregate
  foreach my $angle ( 'major', @$rotamer_names ) {
    
    # Transitions
    if ( not defined $agg->{'trans'}{'rotamers'}{'data'}{$angle} ) { 
      $agg->{'trans'}{'rotamers'}{'data'}{$angle} = [];
    }
    Combine_Histograms_2D ( $agg->{'trans'}{'rotamers'}{'data'}{$angle}, $data->{'trans'}{'rotamers'}{'data'}{$angle} );
    # Wait Counts and Times
    $agg->{'wait_counts'}{$angle} = {} if ( not exists $agg->{'wait_counts'}{$angle} );
    $agg->{'wait_times' }{$angle} = {} if ( not exists $agg->{'wait_times' }{$angle} );
    foreach my $rot ( keys %{$data->{'wait_counts'}{$angle}} ) {
      $agg->{'wait_counts'}{$angle}{$rot} = [] if ( not exists $agg->{'wait_counts'}{$angle}{$rot} );
      $agg->{'wait_times' }{$angle}{$rot} = [] if ( not exists $agg->{'wait_times' }{$angle}{$rot} );
      Combine_Histograms ( $agg ->{'wait_counts'}{$angle}{$rot}, 
                           $data->{'wait_counts'}{$angle}{$rot}, 
                           1.0, 
                           1.0 );
                           #$data->{'distribution'}{$angle}{$rot} ); 
                           # Not sure why I'd normalize like this. This devalues 
                           # the rotamer counts based on how often this one angle 
                           # changed relative to all the angle changes in a residues.  
                           # Same for wait_times below.

      Combine_Histograms ( $agg ->{'wait_times'}{$angle}{$rot},
                           $data->{'wait_times'}{$angle}{$rot},
                           1.0,
                           1.0 );
                           #$data->{'distribution'}{$angle}{$rot} );
      
    }
  }

  $self->Copy_Metadata ( $agg, $data );
  $agg->{'populated'} = 1;
  return $agg;
}


########################################################## NORMALIZE

sub Normalize {

  my $self = $_[0];
  my $data = $_[1];

  my $wait_counts = $data->{'wait_counts'};
  my $wait_times  = $data->{'wait_times' };
  my $trans = $data->{'trans'};

  my $rotamer_names = $data->{'rotamer_names'};
  my $angle_names   = $data->{'angle_names'};
  my $total_rotamers = $data->{'total_rotamers'};

  foreach my $angle ( @$rotamer_names, 'major' ) {
    foreach my $rotamer ( keys %{$wait_counts->{$angle}} ) {
      $data->{'distribution'}{$angle}{$rotamer} = (Hist_Mean_and_Stddev($wait_counts->{$angle}{$rotamer}))[3];
    }
  }

  foreach my $angle ( @$angle_names ) { 
    Normalize_Histogram_2D ( $trans->{'dihedrals'}{'data'}{$angle} );
  }

  foreach my $angle ( 'major', @$rotamer_names ) { 
    Normalize_Histogram_2D ( $trans->{'rotamers'}{'data'}{$angle} );
    foreach my $rotamer ( keys %{$wait_counts->{$angle}} ) {
      if ( $data->{'distribution'}{$angle}{$rotamer} ) {
        $data->{'distribution'}{$angle}{$rotamer} /= $data->{'distribution'}{$angle}{'all'};
      }
      #Zero_Blanks_In_Histogram ( $wait_counts->{$angle}{$rotamer} );
      Normalize_Histogram ( $wait_counts->{$angle}{$rotamer} );
      Normalize_Histogram ( $wait_times ->{$angle}{$rotamer} );
    }
  }

  #$self->Analyze_Secondary ( $data );
  
  $data->{'normalized'} = 1;

}


############################################################# OUTPUT

sub Output {

  my $self = $_[0];
  my $agg  = $_[1];
  my $dir  = $_[2];

  return if not $agg->{'populated'};

  if ( not $agg->{'normalized'} ) { $self->Normalize($agg); }

  $self->Analyze_Secondary ( $agg );

  $self->Print_Dynamics_Values ( $agg, $dir, "mean_counts",    "%.2f" );
  $self->Print_Dynamics_Values ( $agg, $dir, "stddev_counts",  "%.2f" );
  $self->Print_Dynamics_Values ( $agg, $dir, "mean_times",     "%.2f" );
  $self->Print_Dynamics_Values ( $agg, $dir, "stddev_times",   "%.2f" );
  #$self->Print_Dynamics_Values ( $agg, $dir, "changes", "%u"   );
  #$self->Print_Dynamics_Values ( $agg, $dir, "total",   "%u"   );
  #$self->Print_Dynamics_Values ( $agg, $dir, "decay",   "%.4f" );
  
  $self->Print_Dynamics_Array  ( $agg, $dir, "wait_counts",   "%.10f",  sub{$_[0]} );
  $self->Print_Dynamics_Array  ( $agg, $dir, "wait_times",    "%.10f",  sub{$_[0]} );
  foreach my $log ( @{$self->{'logarithms'}} ) {
    $self->Print_Dynamics_Array( $agg, $dir, "log$log\_counts", "%.10f",  sub{$log**$_[0]} );
    $self->Print_Dynamics_Array( $agg, $dir, "log$log\_times",  "%.10f",  sub{$log**$_[0]} );
  }

  ##### TRANSITION MATRICES
  my $trans = $agg->{'trans'};
  $self->Print_Transition_Matrix ( $trans->{'rotamers'},  $dir );
  $self->Print_Transition_Matrix ( $trans->{'dihedrals'}, $dir );

}

sub Print_Transition_Matrix {
  my $self    = $_[0];
  my $agg     = $_[1];
  my $dir     = $_[2];

  Make_Directories ( $dir );
  my $data   = $agg->{'data'};
  my $legend = $agg->{'legend'};
  my $angles = $agg->{'angles'};
  my $file   = "$dir/$agg->{'file'}";

  open OUT, ">:gzip", "$file.gz" or die "Couldn't open transitions file, '$file'. $!";


  foreach my $angle ( @$angles ) {
    # header line for angle
    print OUT "$angle\tangle\t" . (join "\t", @{$legend->{$angle}}) . "\n";

    # data for 
    my $l = scalar @{$legend->{$angle}};
    foreach my $j ( 0..$l-1 ) {
      printf OUT "$angle\t$legend->{$angle}[$j]";
      foreach my $i ( 0..$l-1 ) {
        if ( defined $data->{$angle}[$i][$j] ) { printf OUT "\t%.8f", $data->{$angle}[$i][$j] }
        else                                   { printf OUT "\t0" }
      }
      
      printf OUT "\n";
    }
  }


  close OUT or die "Couldn't close transitions file, '$file'. $!";
}

sub Print_Dynamics_Values {
  my $self    = $_[0];
  my $agg     = $_[1];
  my $dir     = $_[2];
  my $title   = $_[3];
  my $format  = $_[4];

  Make_Directories($dir);
  my $rotamer_names  = $agg->{'rotamer_names'};
  my $total_rotamers = $agg->{'total_rotamers'};
  my $res            = $agg->{'res_name'};
  my $values         = $agg->{$title};
  my $conformations  = $agg->{'residue'}{'conformations'};
  my $x;

  my $file = "$dir/$self->{'files'}{'dynamics_values'}.$title.dat";
  open OUT, ">:gzip", "$file.gz" or die "Couldn't open dynamics values file, '$file'. $!";

  printf OUT "#Title\tRes\tMajor\t" 
           . (join "\t", 
               ( @$rotamer_names ),
               ( map { "Major_$_" } 1..$total_rotamers ),
               ( map { $x=$_; map { "$x\_$_" } @{$conformations->{$x}}  } @$rotamer_names ), 
             )
           . "\n";
  printf OUT "$title"
     . "\t$res\t"
     #. "\t" . ( defined $values->{'major'} ? sprintf $format, $values->{'major'}     : 0 )
     . ( join "\t", 
             map { $values->{$_->[0]}{$_->[1]} ? (sprintf $format, $values->{$_->[0]}{$_->[1]}) : '0' } 
                # All Data
                (['major', 'all']), 
                # Individual Chi Angles
                ( map { [$_, 'all'] } @$rotamer_names ),
                # Individual Major Rotamers
                ( map { ['major', $_] } 0..$total_rotamers-1 ),
                # Individual Chi Angle Minors
                ( map { $x=$_; map { [$x, $_] } 0..$#{$conformations->{$x}}  } @$rotamer_names ),
       )
     . "\n"
     ;
  close OUT or die "Couldn't close dynamics values file, '$file'. $!";
}

sub Print_Dynamics_Array {
  my $self        = $_[0];
  my $agg         = $_[1];
  my $dir         = $_[2];
  my $title       = $_[3];
  my $format      = $_[4];
  my $function    = $_[5];

  Make_Directories($dir);
  my $rotamer_names  = $agg->{'rotamer_names'};
  my $total_rotamers = $agg->{'total_rotamers'};
  my $res            = $agg->{'res_name'};
  my $arrays         = $agg->{$title};
  my $conformations  = $agg->{'residue'}{'conformations'};
  my $x;

  my $file = "$dir/$self->{'files'}{'dynamics_arrays'}.$title.dat";
  open OUT, ">:gzip", "$file.gz" or die "Couldn't open dynamics values file, '$file'. $!";
  printf OUT "#Title\tRes\tValue\tMajor\t" 
           . (join "\t", 
               ( @$rotamer_names ),
               ( map { "Major_$_" } 1..$total_rotamers ),
               ( map { $x=$_; (map { "$x\_$_" } @{$conformations->{$x}})  } @$rotamer_names ) )
           . "\n";
  
  my $max_value = Max ( map { scalar @{$arrays->{$_}{'all'}}-1 } ('major', @$rotamer_names) );
  foreach my $i ( 0..$max_value ) {
    printf OUT "$title"
       . "\t$res"
       . "\t" . (&$function($i)) . "\t"
       . ( join "\t", 
             map { $arrays->{$_->[0]}{$_->[1]}[$i] ?  (sprintf $format, $arrays->{$_->[0]}{$_->[1]}[$i]) : '0' } 
                # All Data
                ['major', 'all'], 
                # Individual Chi Angles
                ( map { [$_, 'all'] } @$rotamer_names ),
                # Individual Major Rotamers
                ( map { ['major', $_] } 0..$total_rotamers-1 ),
                # Individual Chi Angle Minors
                ( map { $x=$_; map { [$x, $_] } @{$conformations->{$x}}  } @$rotamer_names ),
                #( map { $x=$_; map { [$x, $_] } 0..$#{$conformations->{$x}}  } @$rotamer_names ),
       )


       . "\n"
       ;
  }
  close OUT or die "Couldn't close dynamics values file, '$file'. $!";
}

sub Copy_Metadata {
  my $self  = $_[0];
  my $agg   = $_[1];
  my $data  = $_[2];

  foreach my $key ( @{$self->{'metadata'}} ) {
    if ( exists $data->{$key} ) {
      $agg->{$key} = $data->{$key};
    }
  }
}


1;
__END__


