#!/usr/bin/perl

BEGIN{
  push @INC,
            "/users/scouras/code",
            "/users/scouras/code/scouras",
            "/Users/lexicon/lab/code",
            "/Users/lexicon/lab/code/scouras",
            "/net/programs/perl",
#            "/net/programs/perl/lib64/perl5/site_perl/5.8.5/x86_64-linux-thread-multi/",
            "/net/programs/perl/lib/perl5/site_perl/5.8.5/i386-linux-thread-multi",

}

use warnings;
use strict;
use Data::Dumper;
$Data::Dumper::Indent = 2;
use POSIX;
use Getopt::Long;
#use Time::HiRes qw ( gettimeofday tv_interval );
#use Benchmark;


use Utility ':all';
#qw(AA MIN MAX UNIQUE RANGE);
use RotLib::Rotamer;
use RotLib::SASA;
use RotLib::Library;
#use RotLib::Dihedral;
use RotLib::Dynamics;
use RotLib::StateCounts;

####################################################################
# Rotamer Library Generator
#-------------------------------------------------------------------
# Alex Scouras
# Daggett Lab
# Created: 3 November 2004
#-------------------------------------------------------------------
# This software takes molecular dynamics simulations generated using
# ILMM and generates a backbone independent
# rotamer library as as described in the paper
#   Dunbrack and Cohen - Protein Science 1997
#     Bayesian Statistical Analysis of Protein Side-Chain 
#     Rotamer Preferences
#-------------------------------------------------------------------
# This file handles arguments, chosing which library to use, what
# dataset to use, what directories to put things in, etc.  It loads
# the protein list and verifies that all the directories are in
# place.  It performs no calculations itself, instead opting to 
# call Rotamer.pm to load the actual dihedral data and calculate the
# rotamers.  It then calls the analysis modules (Library, SASA, 
# Dynamics, StateCounts) for each simulation, directory, and 
# globally to perform secondary analysis and aggregate the library 
# and analyses at each tier. Finally, it calls each analysis to 
# have it output the final data.
####################################################################

# TODO: Arguments
# protein, dihedral, rotamer list
# cache override
# residues 
#
#

####################################################################
#                                                      CONFIGURATION
####################################################################

#################################################### WHAT TO PROCESS
my %DO = (
  'library'             => 1,
  'dynamics'            => 1,
  'state_counts'        => 1,
  'sasa'                => 1,
);


########### CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
my %CONFIG = ();
'$Revision: 1.1.1.1 $'          =~ /^.Revision: (.*) \$/; $CONFIG{'revision'}  = $1;
'$Date: 2009/03/25 18:32:30 $'  =~ /^.Date: (.*) \$/;     $CONFIG{'checkedin'} = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   $CONFIG{'author'}    = $1;

###################################### CURRENT EXECUTION INFORMATION
$CONFIG{'pwd'}         = `pwd`;        chomp $CONFIG{'pwd'};
$CONFIG{'host'}        = `hostname`;   chomp $CONFIG{'host'};
$CONFIG{'start_time'}  = `date`;       chomp $CONFIG{'start_time'};
$CONFIG{'user'}        = `whoami`;     chomp $CONFIG{'user'};



########################################################## SETTINGS

$CONFIG{'just_make_cache_rotamer_files'} = 0;


# GLOBAL EFFECTS
#$CONFIG{'data_set'}               = 'dunbrack';
#$CONFIG{'data_set'}               = 'test1';
#$CONFIG{'data_set'}               = 'native_810_test';
$CONFIG{'data_set'}               = 'native_807_test';
$CONFIG{'configuration'}          = '';
$CONFIG{'overwrite'}              =  0;
if ( $CONFIG{'host'} =~ /chromium/i ) { $CONFIG{'home_dir'} = '/Users/lexicon/lab/' }
else                                  { $CONFIG{'home_dir'} = '/users/scouras/'    }
$CONFIG{'root_dir'}               = "$CONFIG{'home_dir'}rotamers/";

$CONFIG{'dihedral_dir_preferred'} = 'dihedral';
$CONFIG{'dihedral_dirs'}          = 'dihedral*';
$CONFIG{'residue_string'}         = '';
#$CONFIG{'bin_width'}              = 20;

# formatting
$CONFIG{'sequence_break'} = 50;
$CONFIG{'sequence_space'} = 5;
my $BREAK_LINE = '-' x 69 . "\n";

# timing
$CONFIG{'timing'}         = 2;
$CONFIG{'timing_default'} = 3;

# 
$CONFIG{'rotamer_mode'} = 'static';

$CONFIG{'skip_terminal_residues'} = 1;
$CONFIG{'output_individual_residues'} = 0;
$CONFIG{'output_simgroup_residues'} = 0;
$CONFIG{'overwrite_rotamers'} = 0;
$CONFIG{'overwrite_dihedrals'} = 0;


$CONFIG{'min_simulation_time'} = 19999;

########################################################## DATA SETS
my %DATA_SETS = (

  #################### EXPERIMENTAL 

  ##### ASTRAL40
  'astral40' => {
    'title'        => 'astral40',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.astral40.list',
    'skip_terminal_residues' => 0,
    'sasa' => 0,
  },
  ##### LOVELL
  'lovell' => {
    'title'        => 'lovell',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.lovell.list',
    'skip_terminal_residues' => 0,
    'sasa' => 0,
  },
  ##### DUNBRACK
  'dunbrack' => {
    'title'        => 'dunbrack',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dunbrack.list',
    'skip_terminal_residues' => 0,
    'sasa' => 0,
  },
  
  #################### DYNAMEOMICS 188

  ##### PRION SPECIES
  'prion_species' => {
    'title'         => 'prion_species',
    'protein_file'  => '/users/scouras/rotamers/rotamers.prion.species.list',
    #'protein_file'  => $CONFIG{'root_dir'} . '/wt_hpc_mutants.298.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'output_simgroup_residues' => 1,
    'sasa' => 0,
  },

  ##### PRION HUMAN
  'prion_human' => {
    'title'         => 'prion_human',
    'protein_file'  => '/users/mwvdk/rotamers/rotamers.prion.list',
    #'protein_file'  => $CONFIG{'root_dir'} . '/wt_hpc_mutants.298.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'output_simgroup_residues' => 1,
    'sasa' => 0,
  },
 
  ##### DYNAMEOMICS CONTROL
  'control_188' => {
    'title'        => 'control',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.control.list',
    'skip_terminal_residues' => 0,
    'output_individual_residues' => 0,
    'sasa' => 0,
  },
  ##### NATIVE 188
  'native_188' => {
    'title'        => 'dynameomics_native_188',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.188.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
   ##### NATIVE 188
  'native_188_hercules' => {
    'title'        => 'dynameomics_native_188_hercules',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.188.HERCULES.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  
  #################### DYNAMEOMICS 810
 
  ##### NATIVE 810 CONTROL
  'native_810_control_test' => {
    'title'        => 'dynameomics_native_810_control_test',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.810.control_test.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 0,
    'sasa' => 0,
  },
  ##### NATIVE 810 CONTROL
  'native_810_control' => {
    'title'        => 'dynameomics_native_810_control',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.810.control.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 0,
    'sasa' => 0,
  },
  ##### NATIVE 807 TOP 10
  'native_807_top10' => {
    'title'        => 'dynameomics_native_807_top10',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.807.top10.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  ##### NATIVE 807 TOP 100
  'native_807_top100' => {
    'title'        => 'dynameomics_native_807_top100',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.807.top100.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  ##### NATIVE 807
  'native_807' => {
    'title'        => 'dynameomics_native_807',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.807.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  ##### NATIVE 810
  'native_810' => {
    'title'        => 'dynameomics_native_810',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.810.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  ##### NATIVE TEST 1
  'test1' => {
    'title'        => 'test_1',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.test1.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
    'output_individual_residues' => 1,
  },
  
  #################### DYNAMEOMICS 188 TRANSITION AND DENATURED
 
  ##### TRANSITION STATE
  'ts' => {
    'title'        => 'dynameomics_ts',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.498.ts.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
  ##### DENATURED
  'denatured' => {
    'title'        => 'dynameomics_denatured',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.498.denatured.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
  ##### 10plusNS
  '10plusNS' => {
    'title'        => 'dynameomics_denatured_10plusNS',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.498.10plusNS.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
  
  #################### GGXGG
 
  ##### GGXGG
  'ggxgg' => {
    'title'        => 'ggxgg',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.ggxgg.298.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
  ##### GGXGG 498
  'ggxgg498' => {
    'title'        => 'ggxgg498',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.ggxgg.498.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
  
  #################### FAKE
 
  ##### FAKE
  'fake' => {
    'title'        => 'fake',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.fake.list',
    'skip_terminal_residues' => 1,
    'sasa' => 0,
  },
);


################################################## READ COMMAND LINE


foreach my $arg (@ARGV) {
  my ( $r, $v ) = split /\=/, $arg;
  if    ( $r =~ /^res$/               ) { $CONFIG{'residue_string'      } = $v; }
  elsif ( $r =~ /^set$/               ) { $CONFIG{'data_set'            } = $v; }
  elsif ( $r eq 'overwrite'           ) { $CONFIG{'overwrite_rotamers'  } =  1; }
  elsif ( $r eq 'overwrite_rotamers'  ) { $CONFIG{'overwrite_rotamers'  } =  1; }
  elsif ( $r eq 'overwrite_dihedrals' ) { $CONFIG{'overwrite_dihedrals' } =  1; }
  elsif ( $r eq 'static'              ) { $CONFIG{'rotamer_mode'        } = 'static'; }
  elsif ( $r eq 'dynamic'             ) { $CONFIG{'rotamer_mode'        } = 'dynamic'; }
  else                                  { die "Unknown command line option. $arg\n"; }
}


if ( $CONFIG{'residue_string'} ) {
  $CONFIG{'residue_list'} = [split /,/, $CONFIG{'residue_string'}];
} else {
  $CONFIG{'residue_list'} = [Utility::Unique ( map { uc } keys %AA )];
}

if ( not exists $DATA_SETS{$CONFIG{'data_set'}} ) { 
  die "Unknown data set $CONFIG{'data_set'}";
}
map {$CONFIG{$_}=$DATA_SETS{$CONFIG{'data_set'}}{$_}} keys %{$DATA_SETS{$CONFIG{'data_set'}}};




################################################# RESIDUE NAME CONVERSION
# Fixes for problematic HIS/HID equivalence.  Scoped to hopefully be useful
# if we have more of these issues.

$CONFIG{'residue_conversion'} = { HIS => 'HID' };

#===== Add/remove these virtual residues if necessary
while ( my ($res_virt, $res_real) = each %{$CONFIG{'residue_conversion'}} ) { 
  foreach my $res ( @{$CONFIG{'residue_list'}} ) { 
    if ( $res eq $res_virt ) { $res = $res_real }
  }
}
#die Dumper ( $CONFIG{'residue_list'} );


# !!!!!!!!!!!!!!!!!!!!!!!!!! elebenty
# I am manually overriding outputing of individual residues to save space on Juno at this time.
#$CONFIG{'output_individual_residues'} = 0;


# --- Title or description of run
#     makes it into the output file names.
if ( $CONFIG{'title'} ) { 
  $CONFIG{'output_dir'} = Clean_Filename("rotamers_$CONFIG{'rotamer_mode'}_$CONFIG{'title'}" );}
else { 
  $CONFIG{'output_dir'} = "rotamers_$CONFIG{'rotamer_mode'}";}

if ( $CONFIG{'configuration'} ) { 
  $CONFIG{'protein_summary_dir'} = Clean_Filename("rotamers_$CONFIG{'protein_summary'}" );}
else { 
  $CONFIG{'protein_summary_dir'} = "rotamers"; }

if ( not $CONFIG{'sasa'} ) { $DO{'sasa'} = 0 }




####################################################################
#                                                                   
#                                                              START
#                                                                   
####################################################################


####################################################################
#                                                            WELCOME
####################################################################

$| = 1;

$CONFIG{'version'} 
            = "Version Information\n"
            . "Program Version Information\n"
            . "  Author:        $CONFIG{'author'}\n"
            . "  Revised:       $CONFIG{'checkedin'}\n"
            . "  Versions\n"
            . "    Main:          $CONFIG{'revision'}\n"
            . "    Rotamer:       $RotLib::Rotamer::VERSION\n"
            . "    SASA:          $RotLib::SASA::VERSION\n"
            . "    Library:       $RotLib::Library::VERSION\n"
            . "    State Counts:  $RotLib::StateCounts::VERSION\n"
            . "    Dynamics:      $RotLib::Dynamics::VERSION\n"
            . "Current Execution\n"
            . "  Title:         $CONFIG{'title'}\n"
            . "  Configuration: $CONFIG{'configuration'}\n"
            . "  Proteins:      $CONFIG{'protein_file'}\n"
            . "  User:          $CONFIG{'user'}\n"
            . "  Host:          $CONFIG{'host'}\n"
            . "  Time:          $CONFIG{'start_time'}\n"
            . "  CWD:           $CONFIG{'pwd'}\n"
            ;

# Print welcome and configuration
print "Welcome to $0\n"
    . "If you have problems or suggestions,\n"
    . "please contact Alex at scouras\@u.washington.edu\n\n"
    . $BREAK_LINE
    . "$CONFIG{'version'}"
    . $BREAK_LINE
    ;



####################################################################
#                                                     INITIALIZATION
####################################################################

my (%PROTEINS, @PROTEINS);
{
  my ($p_hash, $p_list) = Load_Protein_List ( \%CONFIG, \%AA );
  %PROTEINS = %$p_hash;
  @PROTEINS = @$p_list;
}

# GLOBAL ANALYSIS OBJECTS
my $ROT   = RotLib::Rotamer     ->Initialize (\%CONFIG, \%AA, \%PROTEINS);
my $LIB   = RotLib::Library     ->Initialize (\%CONFIG, \%AA, \%PROTEINS);
my $SASA  = RotLib::SASA        ->Initialize (\%CONFIG, \%AA, \%PROTEINS);
my $DYN   = RotLib::Dynamics    ->Initialize (\%CONFIG, \%AA, \%PROTEINS);
my $SC    = RotLib::StateCounts ->Initialize (\%CONFIG, \%AA, \%PROTEINS);

# INITIAL DATA REPOSITORIES
my $LIB_DATA = $LIB->Initialize_Aggregator ();
my $SC_DATA  = $SC ->Initialize_Aggregator ();
my $DYN_DATA = $DYN->Initialize_Aggregator ();

# INTRA SIMULATION AGGREGATORS
my $LIB_SUB = $LIB->Initialize_Aggregator ();
my $SC_SUB  = $SC ->Initialize_Aggregator ();
my $DYN_SUB = $DYN->Initialize_Aggregator ();

# CROSS SIMULATION AGGREGATORS
my $LIB_AGG = $LIB->Initialize_Aggregator ();
my $SC_AGG  = $SC ->Initialize_Aggregator ();
my $DYN_AGG = $DYN->Initialize_Aggregator ();

# GLOBAL AGGREGATORS
my %LIB_GLO;
my %SC_GLO;
my %DYN_GLO;
foreach my $res_name ( @{$CONFIG{'residue_list'}} ) {
  $AA{$res_name}{'count'} = 0;
  foreach my $sasa_bin ( '.', 0..$SASA->{'max_bins'} ) {
    $AA{$res_name}{'sasa_count'}{$sasa_bin} = 0;
    $LIB_GLO{$res_name}{$sasa_bin} = $LIB->Initialize_Aggregator ();
    $SC_GLO {$res_name}{$sasa_bin} = $SC ->Initialize_Aggregator ();
    $DYN_GLO{$res_name}{$sasa_bin} = $DYN->Initialize_Aggregator ();
  }
}

#$LIB_GLO{'HIS'} = $LIB_GLO{'HID'};
#$SC_GLO {'HIS'} = $SC_GLO {'HID'};
#$DYN_GLO{'HIS'} = $DYN_GLO{'HID'};

print $BREAK_LINE
    . "Rotamer Configuration\n"
    . "Dihedral Def: $ROT->{'files'}{'dihedral_def'}\n"
    . "Rotamer Def:  $ROT->{'files'}{'rotamer_def'}\n"
    ;

#print Dumper ( $AA{"PHE"} );
#print "Max Bins: " . $SASA->{'max_bins'} . "\n";
#exit;


#print Dumper ($AA{'ASP'});


####################################################################
#                                                       PROTEIN LOOP
####################################################################

#===== Start Timing

my $START  = time;
my $LAP    = { 'time' => $START, 'at' => 0 };

#===== Announce 
print $BREAK_LINE
    . "\nAnalyzing Proteins\n"
    ;

my $protein_count = 0;
my $protein_total = scalar @PROTEINS;
my $RES_TOTAL = Sum ( [ map { $AA{$_}{'precount'} } @{$CONFIG{'residue_list'}}] );

#===== Loop Over Proteins

foreach my $protein_name (@PROTEINS) {
  $protein_count++;
  my %protein = %{$PROTEINS{$protein_name}};
  my $protein_dir = $protein{'dir'};

  print "\n\n";
  my $RES_DONE = Sum ( [ map { $AA{$_}{'count'} } @{$CONFIG{'residue_list'}}] );
  mark_time ( $LAP, "Starting a new Protein", 1, $RES_DONE, $RES_TOTAL );
  print "Protein:         $protein_name\n"
      . "Number:          $protein_count/$protein_total\n"
      . "Directory:       $protein{'dir'}\n"
      . "Subdirs (" . (scalar @{$protein{'subdirs'}}) .    "):     " 
                      . (join ", ", @{$protein{'subdirs'}}) . "\n"
      . "Length:          $protein{'length'} residues\n"
      . "Residue Range:   $protein{'residue_range_string'}\n"
      . "Time Range:      $protein{'time_range_string'}\n"
      ;

  if ( not -e $protein{'dir'} ) { 
    print "  Directory doesn't exist, '$protein{'dir'}'\n";
    next;
  }

  if ( $protein{'replicates'} == 0 ) { 
    print "  Protein $protein_name has no good subdirectories\n";
    next;
  }

  ##################################################################
  #  RESIDUE LOOP - Generate and aggregate rotamers for each residue
  #-----------------------------------------------------------------
  # The raw data is stored in a separate file for each angle 
  # ('<angle>_t.dat'), which is a pain to work with, so we have the 
  # shell combine them for us (and much faster than perl would do it)
  #
  # Skip first and last residue because they do not have phi/psi data.
  # Note that we've indexed by residue number, so counting starts at 1.
  ##################################################################

  my @sequence      = @{$protein{'sequence'}};
  my @sequence_full = @{$protein{'sequence_full'}};
  my ( $res_start, $res_stop ) = (1, $#sequence);
  if ( $CONFIG{'skip_terminal_residues'} ) {
    print ' ';
    $res_start = 2;
    $res_stop = $#sequence - 1;
  }
  foreach my $res_num ($res_start..$res_stop ) {
    my $res_name_orig = $sequence[$res_num];
    my $res_name_virt = $res_name_orig;
    if ( exists $CONFIG{'residue_conversion'}{$res_name_orig} ) { 
      $res_name_virt = $CONFIG{'residue_conversion'}{$res_name_orig};
    }
    my $res_name_full = $sequence_full[$res_num];
    

    #=========== Do we process this residue?
    if ( In_Range ( $protein{'residue_intervals'}, $res_num ) 
        and ( defined $res_name_orig )
        and ( exists $AA{$res_name_orig} )
        and ( $AA{$res_name_orig}{'total_rotamers'} > 1 ) 
        and ( (not $CONFIG{'skip_terminal_residues'}) or $res_name_full !~ /_(N|C)$/ )
        and ( not $CONFIG{'residue_string'} 
             or (grep { $_ eq $res_name_orig } @{$CONFIG{'residue_list'} })
             or (grep { $_ eq $res_name_virt } @{$CONFIG{'residue_list'} })
            ) 
      ) {
      print $AA{$res_name_virt}{'ab'};
      if    (not $res_num % $CONFIG{'sequence_break'}) { print "\n" }
      elsif (not $res_num % $CONFIG{'sequence_space'}) { print " "  }
    } else {
      print '_';
      if    (not $res_num % $CONFIG{'sequence_break'}) { print "\n" }
      elsif (not $res_num % $CONFIG{'sequence_space'}) { print " "  }
      next;
    }
    $AA{$res_name_virt}{'count'}++;

    #========== Initialize aggregators for this residue across simulations.
    $LIB->Initialize_Aggregator ($LIB_AGG) if $DO{'library'};
    $SC ->Initialize_Aggregator ($SC_AGG)  if $DO{'state_counts'};
    $DYN->Initialize_Aggregator ($DYN_AGG) if $DO{'dynamics'};

    $LIB->Initialize_Aggregator ($LIB_SUB) if $DO{'library'};
    $SC ->Initialize_Aggregator ($SC_SUB)  if $DO{'state_counts'};
    $DYN->Initialize_Aggregator ($DYN_SUB) if $DO{'dynamics'};

    
    
   
    ################################################################
    # SUBDIRECTORY LOOP 
    #---------------------------------------------------------------
    ################################################################
    my $res_dir = "$res_num\_$res_name_orig";
    my $subdir_count = 0;
    my @sasas = ();
    my @sasa_bins = ();
    foreach my $subdir ( @{$protein{'subdirs'}} ) {

      my $molecule_dir  = $protein{'subdir_data'}{$subdir}{'molecule_dir'};
      my $dir = "$molecule_dir/$res_dir";
      my $dir_out = "$dir/$CONFIG{'rotamer_mode'}";

      #--- SASA Data
      #my ($sasa, $sasa_bin) = (0, 1);
      my ($sasa, $sasa_bin);
      if ( $DO{'sasa'} ) { ($sasa, $sasa_bin) = $SASA->Determine_SASA ( \%protein, $subdir, $res_num ) }
      else               { ($sasa, $sasa_bin) = (0, 1) }
      push @sasas, $sasa;
      push @sasa_bins, $sasa_bin;

      #--- Read Rotamer Data
      my $RES = $ROT->Read_Rotamer_Data ( $protein{'time_intervals'}, $res_name_virt, "$dir" );
      if ( $RES and $CONFIG{'just_make_cache_rotamer_files'} ) { next }
      next if not $RES;
    
      #--- Analyze the data and aggregate to next level.
      if ( $DO{'library'} ) { 
        $LIB->Initialize_Aggregator ($LIB_DATA);
        $LIB->Analyze ( $LIB_DATA, $RES );
        $LIB->Aggregate( $LIB_AGG, $LIB_DATA ); 
      }
      if ( $DO{'state_counts'}    ) { 
        $SC ->Initialize_Aggregator ($SC_DATA);
        $SC ->Analyze ( $SC_DATA, $RES );
        $SC ->Aggregate_Simulations ( $SC_AGG,  $SC_DATA ); 
      }
      if ( $DO{'dynamics'}        ) { 
        $DYN->Initialize_Aggregator ($DYN_DATA);
        $DYN->Analyze ( $DYN_DATA, $RES );
        $DYN->Aggregate ( $DYN_AGG, $DYN_DATA ); 
      }

      # OUTPUT INDIVIDUAL RESIDUES
      if ( $CONFIG{'output_individual_residues'} ) {
        $LIB->Output( $LIB_DATA, $dir_out ) if $DO{'library'};
        #$SC ->Output( $SC_DATA,  $dir ) if $DO{'state_counts'};
        $DYN->Output( $DYN_DATA, $dir_out ) if $DO{'dynamics'};
      }
      $subdir_count++;
    }

    #--- Average SASA over actual used subdirs
    my $sasa = (Mean_and_Stddev ( \@sasas ))[0];
    my $sasa_bin = $SASA->Determine_SASA_Bin ( $res_name_virt, $sasa );
    #print "SASA: $sasa, $sasa_bin, SASAS: " . (join ',', @sasas) . "\n";
    
    #--- Normalize the aggregates and reaggragrate to global
    #$LIB->Aggregate_BBD_to_BBI ( $LIB_AGG );
    foreach my $bin ( '.', grep { defined $_ } $sasa_bin ) {
      $AA{$res_name_virt}{'sasa_count'}{$bin}++;
      if ( $DO{'library'} ) { 
        $LIB->Aggregate( $LIB_GLO{$res_name_virt}{$bin}, $LIB_AGG ); 
      }
      if ( $DO{'state_counts'}    ) { 
        $SC ->Aggregate_Residues ( $SC_GLO{$res_name_virt}{$bin},  $SC_AGG ); 
      }
      if ( $DO{'dynamics'}        ) { 
        $DYN->Aggregate ( $DYN_GLO{$res_name_virt}{$bin}, $DYN_AGG ); 
      }
    }

    # OUTPUT SIMULATION GROUP RESIDUE
    if ( $CONFIG{'output_simgroup_residues'} ) {
      my $res_out = "$protein{'outdir'}/$CONFIG{'rotamer_mode'}/$res_dir";
      #print "OUTPUTTING SIMGROUPS $res_out\n";
      $LIB->Output( $LIB_AGG, $res_out ) if $DO{'library'};
      $SC ->Output( $SC_AGG,  $res_out ) if $DO{'state_counts'};
      $DYN->Output( $DYN_AGG, $res_out ) if $DO{'dynamics'};
    }


  }
}




####################################################################
#                                                             OUTPUT
####################################################################


foreach my $res_name ( @{$CONFIG{'residue_list'}} ) {
  print "\nProcessing output for residue $res_name ($AA{$res_name}{'count'}).\n";
  foreach my $sasa_bin ( '.', 0..$SASA->{'max_bins'}-1 ) {
    my $res_dir = "$CONFIG{'output_dir'}/$res_name/$sasa_bin/";
    print "  Working on residue directory $res_dir.  $AA{$res_name}{'sasa_count'}{$sasa_bin} residues.\n";
    next if not $AA{$res_name}{'sasa_count'}{$sasa_bin};
    Make_Directories ( $res_dir );

    $LIB->Output( $LIB_GLO{$res_name}{$sasa_bin}, $res_dir ) if $DO{'library'};
    $SC ->Output( $SC_GLO {$res_name}{$sasa_bin}, $res_dir ) if $DO{'state_counts'};
    $DYN->Output( $DYN_GLO{$res_name}{$sasa_bin}, $res_dir ) if $DO{'dynamics'};
    
  }
}

print "SUCCESS\n";









####################################################################
#                                                                   
#                                                        SUBROUTINES
#                                                                   
####################################################################

################################################## LOAD PROTEIN LIST
# TODO: Make individual subdirectories of a protein able to handle 
#       different directories, residues, and time selections.
sub Load_Protein_List { 
  my $CONFIG    = $_[0];
  my $AA        = $_[1];
  

  print "\nLoading Proteins\n\n";
  
  my %PROTEINS = ();
  my @PROTEINS = ();
  
  local $| = 1;

  #----- Set counts of amino acids to 0
  for my $res ( keys %$AA ) { 
    $AA->{$res}{'precount'} = 0; 
    $AA->{$res}{'count'   } = 0; 
  }
  
  #-------------------------------------- Read the lines of the file
  my $file = $CONFIG->{'protein_file'};
  my $line;
  open PRO, $file or die "Couldn't open protein file, '$file'. $!";

  my $count = 1;

  while ( defined ( $line = <PRO> ) ) {
    next if ( ( $line = Clean_Line($line) ) eq '' );

    my ( $protein_name, $dir, $subdir, $residue_range, $time_range ) 
      = map { Trim($_) } split ';', $line;

    print "$count\t$protein_name\t$dir\t$subdir\t$residue_range\t$time_range\n";
    $count++;

    if ( not -e $dir ) { 
      print "Protein directory doesn't exist, '$dir'.\n";
      next;
    }

    # These values default to "all" if empty.
    $subdir         = '*' if not defined $subdir        or $subdir        eq '';
    $residue_range  = '*' if not defined $residue_range or $residue_range eq '';
    $time_range     = '*' if not defined $time_range    or $time_range    eq '';
    
      
    # Parse protein subdirectories (default all subdirs unless specified)
    my @subdirs = ();
    foreach my $d ( map { /^\s*\/?(.*?)\s*$/; $1 } split /\,/, $subdir ) {
      push @subdirs, map { m/$dir\/(.*$)/; $1 } grep { -d $_ } glob ( "$dir/$d" );
    }

    if ( not @subdirs ) { next; } # Skip proteins without simulations 
    #------------------------------------------ Parse Residue Ranges
    $residue_range =~ s/\s//g;
    my %residue_intervals = ();
    Process_Range($protein_name, $dir, 'residue', $residue_range, \%residue_intervals);
    #--------------------------------------------- Parse Time Ranges
    $time_range =~ s/\s//g;
    my %time_intervals = ();
    Process_Range($protein_name, $dir, 'time', $time_range, \%time_intervals);

    

    #################################################### THE PROTEIN
    my %protein =  
    (
      'name'                  => $protein_name,
      'dir'                   => $dir,
      'subdir_string'         => $subdir,
      'residue_range_string'  => $residue_range,
      'time_range_string'     => $time_range,
      'outdir'                => "$dir/$CONFIG{'protein_summary_dir'}",
      'subdir_data'           => { map { $_ => {} } @subdirs } ,
      'residue_intervals'     => \%residue_intervals,
      'time_intervals'        => \%time_intervals,
    );

    #---------- FIND EACH SUBDIR'S DIHEDRAL AND MOLECULE DIRECTORIES
    # find all the dihedral dirs.  Take the simple one if it exists, 
    # or the first one otherwise.
    # TODO: Give some way to specify which dihedral dir.
    # $molecule_dir contains the protein and subdir path.
    my $are_good_molecule_dirs = 0;
    foreach my $subdir ( @subdirs ) {

      my @dihedral_dirs = grep { -d $_ } 
                 glob ( "$dir/$subdir/$CONFIG{'dihedral_dir_preferred'}" );
      if ( not @dihedral_dirs ) {
        @dihedral_dirs = grep { -d $_ } 
                 glob ( "$dir/$subdir/$CONFIG{'dihedral_dirs'}" ); }
      my @molecule_dirs = ();
      foreach my $dd ( @dihedral_dirs ) {
        push @molecule_dirs, grep { /\d+_\w+$/ and -d $_ } glob ( "$dd/*_*");
      }
      @molecule_dirs = sort @molecule_dirs;
      
      # Multilple molecules, dunno which one to take.
      if (scalar @molecule_dirs > 1) { 
        @molecule_dirs = $molecule_dirs[0];
#        warn "For protein $protein_name, subdir $subdir, there is more than one molecule "
#           . "in the dihedral directory. We don't know which one "
#           . "to use, because we're a little dumb for now. So we're "
#           . "skipping this subdirectory. Directories: \n" 
#           . (map { sprintf "\t$_\n" } @molecule_dirs) . "). $!";
#        next;
      # Error, no molecules
      } elsif ( not @molecule_dirs ) {
        warn "For protein $protein_name, subdir $subdir, "
           . "there are no dihedral directories, so we are skipping it.\n";
           ;
        next;
      }
      $protein{'subdir_data'}{$subdir}{'molecule_dir'} = $molecule_dirs[0];
      $are_good_molecule_dirs = 1;
    }
    if ( not $are_good_molecule_dirs ) {
      warn "There are no dihedral data directories in any subdirectory "
         . "for the protein $protein_name.  It will be completely skipped. \n";
      next;
    }

    #-------------------------- READ AND CHECK THE PROTEIN SEQUENCES
    # This first directory shall be considered the standard.  The 
    # sequence and length of the protein shall be read from here; 
    # all other subdirectories will be compared to this one.

    my $consensus_on_protein_sequence = 1;
    foreach my $subdir ( @subdirs ) {

      print "  Loading subdir $protein_name/$subdir\n";

      $protein{'subdir_data'}{$subdir}{'is_good'} = 1;
      my $molecule_dir = $protein{'subdir_data'}{$subdir}{'molecule_dir'};


      #---------------------------------------- GET LIST OF RESIDUES
      # Each residue in the protein has its own directory 
      # (like "23_LYS") with its angle information, so we read the 
      # protein sequence from the directory listing.

      my @residue_dirs = reverse sort 
                                   map  { m/$molecule_dir\/(.*?)$/; $1 }
                                     grep { -d $_ and /\/\d+_\w\w\w(_(C|N))?$/} 
                                          glob ("$molecule_dir/*");

      my $bad_dirs = 0;

      #----- Generate sequence from directory listing
      #----- Remove all _C, _N, _whatever subscripts from @sequence
      my @sequence = (undef);  # no 0th residue, 1-indexed array!
      my @sequence_full = (undef);
      
      my $good_resdir;

      #----- Validate each residue
      foreach my $resdir ( @residue_dirs ) { 
        #print ".";
        my ($num, $name, $sub) = split '_', $resdir; 
        my @files = grep { -e } map { "$molecule_dir/$resdir/$_" } qw(summary_t.dat.gz summary_t.dat phi_t.dat psi_t.dat);
        if ( scalar @files == 0 ) {
          $name = 'XXX';
          $bad_dirs ++;
          print "    $protein_name $subdir is missing dihedral data for $resdir.\n";
          next;
        } 

        if ( not defined $good_resdir ) { $good_resdir = $resdir }

         
        $sequence[$num] = $name;
        $sequence_full[$num] = $name . (defined $sub ? "_$sub" : '');
      }

      
      if ( defined $good_resdir ) { 
        
        my @files = grep { -e } map { "$molecule_dir/$good_resdir/$_" } qw(summary_t.dat.gz summary_t.dat phi_t.dat psi_t.dat);
        my $file = $files[0];

        #----- Spot check for adequate analysis time

        my $last_timepoint;
        if ( $file =~ /\.gz/ ) { $last_timepoint = (split /\s+/, `zcat $file | tail -n 1 `)[0] } 
        else                   { $last_timepoint = (split /\s+/, `tail -n 1 $file`)[0]         }
        if ( $last_timepoint < $CONFIG{'min_simulation_time'} ) { 
          print "    $protein_name $subdir doesn't have enough timepoints in $good_resdir ("
              . (sprintf "%.0f", $last_timepoint)
              . " vs. $CONFIG{'min_simulation_time'})\n";
          $protein{'subdir_data'}{$subdir}{'is_good'} = 0;
        }


        #----- Spot check for backtracking 
        #----- (since that happens across the entire group if it happens)
        #my $time_integrity = `perl /users/scouras/code/scouras/check_continuous_analysis_file.pl $file 1`;
        #if ( $time_integrity =~ /Backtracking/mgi ) { 
        #  print "    $protein_name $subdir backtracks in $good_resdir\n";
        #  $protein{'subdir_data'}{$subdir}{'is_good'} = 0;
        #}
      }
      
      
      print "\n";
      
      if ( $bad_dirs > 5 ) { 
        warn "    $protein_name has too many missing residues.  Skipping\n";
        $protein{'subdir_data'}{$subdir}{'is_good'} = 0;
      }

      #----- Check that sequences are identical
      # first simulation for protein, so nothing to verity against.
      if ( not $protein{'length'} ) { 
        $protein{'length'} = $#sequence;
        $protein{'sequence'} = \@sequence;
        $protein{'sequence_full'} = \@sequence_full;
        foreach my $res ( @sequence ) {
          next if not $res or not exists $AA->{$res};
          $AA->{$res}{'precount'}+=1;
        }
      } else { 
        if ( ( $protein{'length'} != $#sequence ) or
             ( grep { not $sequence[$_] 
                      eq $protein{'sequence'}[$_] } 
                   1..$protein{'length'} ) ) {
          warn "For protein $protein_name, simulation replicates have "
             . "different sequences.  We will therefore completely "
             . "skip this protein.\n";
          $consensus_on_protein_sequence = 0;
          $protein{'subdir_data'}{$subdir}{'is_good'} = 0;
          last;
        }
      }
    }

    # Create data directory for this protein
    #if ( not -e "$dir/$CONFIG{'protein_summary_dir'}" ) {
    #  mkdir "$dir/$CONFIG{'protein_summary_dir'}" 
    #    or die "Couldn't make output directory $dir/$CONFIG{'protein_summary_dir'}. $!";
    #}
      
    # Add the subdirectories that actually passed muster
    my @good_subdirs = grep { $protein{'subdir_data'}{$_}{'is_good'} } keys %{$protein{'subdir_data'}};
    $protein{'subdirs'}    = [sort @good_subdirs];
    $protein{'replicates'} = scalar @good_subdirs;

    $PROTEINS{$protein_name} = \%protein;
    push @PROTEINS, $protein_name;

    #print "GOOD SUBDIRS: " .  Dumper (@good_subdirs);
    #exit;

  }
  close PRO or die "Couldn't close protein file, '$file'. $!";

  return (\%PROTEINS, \@PROTEINS);
}





####################################################################
#                                                 TIMING SUBROUTINES
####################################################################
sub mark_time {
  my $lap   = $_[0];
  my $note  = $_[1];
  my $level = $_[2] || $CONFIG{'timing_defalut'};
  my $at    = $_[3] || 1;
  my $total = $_[4] || 1;

  return if $CONFIG{'timing'} < $level;
  my $togo = ( $total ? $total - $at : 0 );
  my $last_time = $lap->{'time'};
  my $last_at   = $lap->{'at'};

  my $now   = time;
  my $elapsed_time = $now-$last_time || 1;
  my $elapsed_at   = $at - $last_at || 1;

  printf "Total: " . (make_hour_min_sec($now-$START)) . "  "
       . "Lap: "   . (make_hour_min_sec($now-$last_time)) 
       . ( $togo 
            ? "  ETA: " . (make_hour_min_sec(($now-$START)/$at*$togo)) 
              . " - " . (make_hour_min_sec(($elapsed_time/$elapsed_at)*$togo))
            : "" )
       . ".  " . $note . "\n";
  $lap->{'time'} = $now;
  $lap->{'at'} = $at;
  
}

sub make_hour_min_sec {
  my $seconds = $_[0];
  my $hoursec = 60*60;
  my $minsec  = 60;
  my $secsec  = 1;

  my $string = sprintf "%02u:%02u:%02u", 
   POSIX::floor(($seconds           ) / $hoursec),
   POSIX::floor(($seconds % $hoursec) / $minsec ),
   POSIX::floor(($seconds % $minsec ) / $secsec ),
   ;  
  return $string;
}




