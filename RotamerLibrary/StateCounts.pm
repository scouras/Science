package RotLib::StateCounts;

#use 5.008006;
use strict;
use warnings;
use Data::Dumper;
require Exporter;

use Utility ':all';

our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use RotLib ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	
) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw(
	
);


# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.1.1.1 $'              =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/03/25 18:32:30 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;


our %FILES_SC = (
  
  # OUTPUT
  state_counts       => 'state_counts.dat',
  
);

our %CONFIG_SC = (

  max_states => 30,
  thresholds         => [ 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 
                          0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95 ],
  files => \%FILES_SC,
  
);

######################################################### INITIALIZE

sub Initialize {
  
  my $class     = $_[0];
  my $CONFIG    = $_[1];
  my $AA        = $_[2];
  my $PROTEINS  = $_[3];

  my $SC = {%CONFIG_SC};

  bless $SC, $class;
  
  $SC->{'AA'} = $AA;
  $SC->{'main'} = $CONFIG;
  
  return $SC;

};


############################################## INITIALIZE AGGREGATOR

sub Initialize_Aggregator {

  my $self = $_[0];
  my $agg  = $_[1] || {};
  
  $agg->{'count'} = 0;
  $agg->{'normalized'} = 0;
  $agg->{'data_type'} = '';
  $agg->{'res_name'} = '';


  # Rotamer Data
  my $rotamer_major;
  if ( exists $agg->{'rotamer_major'} ) { $rotamer_major = $agg->{'rotamer_major'} }
  else                                  { $rotamer_major = [] };
  for my $i ( 0..$#$rotamer_major) {
    $agg->{'rotamer_major'}[$i] = 0;
  }
  $agg->{'rotamer_major'} = $rotamer_major;

  # State Counts - initialize counts to 0
  my $max_states = $self->{'max_states'};
  my $states;
  if ( exists $agg->{'states'} ) { $states = $agg->{'states'} }
  else                           { $states = {}; }
  foreach my $t ( @{$self->{'thresholds'}} ) {
    foreach my $c ( 0..$max_states ) {
      $states->{$t}[$c] = 0;
    }
  }
  $agg->{'states'} = $states;
  return $agg;
  
}


############################################### STATE COUNT ANALYSIS

sub Analyze {

  my $self = $_[0];
  my $data = $_[1];
  my $RES  = $_[2];

  my $new_majors = $RES->{'histograms'}{'rotamer_major'};
  my $res  = $self->{'AA'}{$RES->{'res_name'}};
  my $total_rotamers = $RES->{'total_rotamers'};
  
  my $timepoints     = $RES->{'timepoints'};
  
  # State counts want the histograms normalized to frequencies.
  for my $i ( 0..$total_rotamers-1 ) {
    if ( not defined $new_majors->[$i] ) {
      $data->{'rotamer_major'}[$i] = 0;
    } else {
      $data->{'rotamer_major'}[$i] = $new_majors->[$i] / $timepoints;
    }
  }
  $data->{'res_name'      } = $RES->{'res_name'};
  $data->{'count'         } = 1;
  $data->{'normalized'    } = 0;
  $data->{'data_type'     } = 'rotamer';
  $data->{'total_rotamers'} = $RES->{'total_rotamers'};
}

############################################## AGGREGATE SIMULATIONS

sub Aggregate_Simulations {

  my $self = $_[0];
  my $agg  = $_[1];
  my $data = $_[2];

  if ( $agg->{'normalized'} ) {
    die "State Counts: The aggregator has already been normalized, you can't add more data to it.";
  }

  if ( $agg->{'res_name'} ) { 
    if ( $agg->{'res_name'} ne $data->{'res_name'} ) {
      die "State Counts: Aggregator ($agg->{'res_name'}) and Data ($data->{'res_name'}) do not address the same residue.";
    } 
  } else {
    $agg->{'res_name'} = $data->{'res_name'};
  }

  if ( not $data->{'normalized'} ) { $self->Normalize($data) };

  my $total_rotamers = $data->{'total_rotamers'};
  foreach my $i ( 0..($total_rotamers-1)) {
    if ( not defined $agg->{'rotamer_major'}[$i] ) 
      { $agg->{'rotamer_major'}[$i] = 0; }
      
    $agg->{'rotamer_major'}[$i] += $data->{'rotamer_major'}[$i];
  }
  $agg->{'count'}++;
  $agg->{'data_type' } = 'rotamer';
}

################################################# AGGREGATE RESIDUES

sub Aggregate_Residues {

  my $self = $_[0];
  my $agg  = $_[1];
  my $data = $_[2];

  if ( $agg->{'normalized'} ) {
    die "State Counts: The aggregator has already been normalized, you can't add more data to it.";
  }
  
  my $total_rotamers;
  if ( not $data->{'normalized'} ) { $self->Normalize($data) };
  if ( $agg->{'res_name'} ) { 
    if ( $agg->{'res_name'} ne $data->{'res_name'} ) {
      die "State Counts: Aggregator ($agg->{'res_name'}) and Data ($data->{'res_name'}) do not address the same residue.";
    } 
  } else {
    $agg->{'res_name'} = $data->{'res_name'};
  } 



  # Aggregating from histograms to state counts
  if ( $data->{'data_type'} eq 'rotamer') {

    my @freqs = @{$data->{'rotamer_major'}};
    my $count;
    my $max_states = $self->{'max_states'};

    # count the states for this residue at each threshold
    foreach my $t ( @{$self->{'thresholds'}} ) {
      $count = grep { $_>=$t } @freqs;
      if ( $count > $max_states ) { $count = $max_states }
      $agg->{'states'}{$t}[$count]++;
    }
    $agg->{'count'    }++;
    $agg->{'normalize'} = 0;
    $agg->{'data_type'} = 'state';
    return;


  # Aggregating state counts from many residues
  } elsif ( $data->{'data_type'} eq 'state') {
    my $max_states = $self->{'max_states'};
    foreach my $t ( @{$self->{'thresholds'}} ) {
      foreach my $c ( 0..$max_states ) {
        $agg->{'states'}{$t}[$c] += $data->{'states'}{$t}[$c];
      }
    }
    $agg->{'count'    }++;
    $agg->{'normalize'} = 0;
    $agg->{'data_type'} = 'state';
    return;
  } else {
    die "State Counts: Unknown data type, '$data->{'data_type'}'.";
  }
}


sub Normalize {

  my $self = $_[0];
  my $data = $_[1];

  my $count = $data->{'count'};

  # Doesn't need normalization
  if ( $count == 1 or $data->{'normalized'}) { 
    $data->{'normalized'} = 1;
    return;
  };
  
  # Um, no data?  This shouldn't ever happen.
  if ( $count < 1 ) {
    die "Cannot normalize state counts, no data (count=$count).\n";
  }
  
  # normalize histogram
  for my $i ( 0..scalar @{$data->{'rotamer_major'}}-1) {
    $data->{'rotamer_major'}[$i] /= $count;
  }

  # normalize state counts
  for my $t ( @{$self->{'thresholds'}} ) {
    foreach my $c ( 0..$self->{'max_states'} ) {
      $data->{'states'}{$t}[$c] /= $count;
    }
  }
  
  $data->{'normalized'} = 1;
}


############################################################# OUTPUT

sub Output { 

  my $self  = $_[0];
  my $agg   = $_[1];
  my $dir   = $_[2];

  $self->Output_State_Counts ( $agg, $dir );
}
  
sub Output_State_Counts {

  my $self  = $_[0];
  my $agg   = $_[1];
  my $dir   = $_[2];

  my $file = "$dir/$self->{'files'}{'state_counts'}";
  my $count = $agg->{'count'};
  Make_Directories ( $dir );
  
  return if not $agg->{'count'};
  if ( not $agg->{"normalized"} ) { $self->Normalize ($agg) }

  open OUT, ">$file" or die "Couldn't open state counts output file, '$file'. $!";

  printf OUT "# State Counts for residue: $agg->{'res_name'}\n"
           . "# Total residues: $count\n"
           . "#THRESH\t" . ( join "\t", (0..$self->{'max_states'}) ) . "\n";

  foreach my $t ( @{$self->{'thresholds'}} ) {
    printf OUT "%f", $t;
    foreach my $c ( 0..$self->{'max_states'} ) {
      if ( not defined $agg->{'states'}{$t}[$c] ) { $agg->{'states'}{$t}[$c] = 0; }
      printf OUT "\t%.4f", $agg->{'states'}{$t}[$c];
    }
    printf OUT "\n";
  }
}


1;
__END__


