#!/usr/bin/perl

BEGIN{
  push @INC, #"/net/programs/perl",
             #"/net/programs/perl/lib64/perl5/5.8.3/x86_64-linux-thread-multi",
             #"/users/scouras/downloads/PERL/Time-HiRes-1.9707/";
             #"/net/programs/perl/modules",
             "/users/scouras/code",
             "/users/scouras/code/scouras",
             "/Users/lexicon/lab/code",
             "/Users/lexicon/lab/code/scouras",

}

use warnings;
use strict;
use Data::Dumper;
$Data::Dumper::Indent = 2;
use POSIX;
use Getopt::Long;
#use Time::HiRes qw ( gettimeofday tv_interval );
#use Benchmark;


use Utility ':all';
#qw(AA MIN MAX UNIQUE RANGE);
use RotLib::SASA;

####################################################################
# Rotamer Dynamics Comparator
#-------------------------------------------------------------------
# Alex Scouras
# Daggett Lab
# Edited 16 Oct 2009
#-------------------------------------------------------------------
# This program compares S2 order parameters, Dihedral order
# parameters, and rotamer waiting times
####################################################################



####################################################################
#                                                      CONFIGURATION
####################################################################

#################################################### WHAT TO PROCESS
my %DO = (
  'library'             => 1,
  'dynamics'            => 1,
  'state_counts'        => 1,
  'sasa'                => 1,
);


########### CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
my %CONFIG = ();
'$Revision: 1.1.1.1 $'              =~ /^.Revision: (.*) \$/; $CONFIG{'revision'}  = $1;
'$Date: 2009/03/25 18:32:30 $'  =~ /^.Date: (.*) \$/;     $CONFIG{'checkedin'} = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   $CONFIG{'author'}    = $1;

###################################### CURRENT EXECUTION INFORMATION
$CONFIG{'pwd'}         = `pwd`;        chomp $CONFIG{'pwd'};
$CONFIG{'host'}        = `hostname`;   chomp $CONFIG{'host'};
$CONFIG{'start_time'}  = `date`;       chomp $CONFIG{'start_time'};
$CONFIG{'user'}        = `whoami`;     chomp $CONFIG{'user'};



########################################################## SETTINGS

# GLOBAL EFFECTS
$CONFIG{'data_set'}               = 'native_810';
#$CONFIG{'data_set'}               = 'test1';
#$CONFIG{'data_set'}               = 'dunbrack';
$CONFIG{'configuration'}          = '';
$CONFIG{'overwrite'}              =  0;
if ( $CONFIG{'host'} =~ /cobalt/i ) { $CONFIG{'home_dir'} = '/Users/scouras/lab/' }
else                                { $CONFIG{'home_dir'} = '/users/scouras/'    }
$CONFIG{'root_dir'}               = "$CONFIG{'home_dir'}rotamers/";

$CONFIG{'dihedral_dir_preferred'} = 'dihedral';
$CONFIG{'dihedral_dirs'}          = 'dihedral*';
$CONFIG{'residue_string'}         = '';
#$CONFIG{'bin_width'}              = 20;

# formatting
$CONFIG{'sequence_break'} = 50;
$CONFIG{'sequence_space'} = 5;

# timing
$CONFIG{'timing'}         = 2;
$CONFIG{'timing_default'} = 3;

# 
$CONFIG{'rotamer_mode'} = 'dynamic';

$CONFIG{'skip_terminal_residues'} = 1;
$CONFIG{'output_individual_residues'} = 0;
$CONFIG{'overwrite_rotamers'} = 0;
$CONFIG{'overwrite_dihedrals'} = 0;

########################################################## DATA SETS
my %DATA_SETS = (
  ##### NATIVE
  'native_810' => {
    'title'        => 'dynameomics_native_810',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.810.list',
    'skip_terminal_residues' => 1,
    'output_individual_residues' => 1,
    'sasa' => 1,
  },
  
  ##### NATIVE TEST 5
  'native_810_top10' => {
    'title'        => 'dynameomics_native_810_top10',
    'protein_file' => $CONFIG{'root_dir'} . '/proteins.dynameomics.298.810.top10.list',
    'skip_terminal_residues' => 1,
    'sasa' => 1,
  },
);


################################################## READ COMMAND LINE


foreach my $arg (@ARGV) {
  $arg =~ s/^.*\///g;
  my ( $r, $v ) = split /\=/, $arg;
  if    ( $r =~ /^res$/       ) { $CONFIG{'residue_string'  } = $v; }
  elsif ( $r =~ /^set$/       ) { $CONFIG{'data_set'        } = $v; }
  elsif ( $r eq 'overwrite'   ) { $CONFIG{'overwrite_rotamers' } =  1; }
  elsif ( $r eq 'overwrite_rotamers'  ) { $CONFIG{'overwrite_rotamers' } =  1; }
  elsif ( $r eq 'overwrite_dihedrals' ) { $CONFIG{'overwrite_dihedrals' } =  1; }
  elsif ( $r eq 'static'      ) { $CONFIG{'rotamer_mode'    } = 'static'; }
  elsif ( $r eq 'dynamic'     ) { $CONFIG{'rotamer_mode'    } = 'dynamic'; }
  else                          { die "Unknown command line option. $arg\n"; }
}

if ( $CONFIG{'residue_string'} ) {
  $CONFIG{'residue_list'} = [split /,/, $CONFIG{'residue_string'}];
} else {
  $CONFIG{'residue_list'} = [keys %AA];
}

map {$CONFIG{$_}=$DATA_SETS{$CONFIG{'data_set'}}{$_}} keys %{$DATA_SETS{$CONFIG{'data_set'}}};


# --- Title or description of run
#     makes it into the output file names.
if ( $CONFIG{'title'} ) { 
  $CONFIG{'output_dir'} = Clean_Filename("rotamers_$CONFIG{'rotamer_mode'}_$CONFIG{'title'}" );}
else { 
  $CONFIG{'output_dir'} = "rotamers_$CONFIG{'rotamer_mode'}";}

if ( $CONFIG{'configuration'} ) { 
  $CONFIG{'protein_summary_dir'} = Clean_Filename("rotamers_$CONFIG{'protein_summary'}" );}
else { 
  $CONFIG{'protein_summary_dir'} = "rotamers"; }

Make_Directories ( $CONFIG{'output_dir'} );


####################################################### START TIMING

my $START  = time;
my $LAP    = { 'time' => $START, 'at' => 0 };
#my %TIMES = ();
#my $TIME = gettimeofday();





####################################################################
#                                                                   
#                                                              START
#                                                                   
####################################################################


####################################################################
#                                                            WELCOME
####################################################################


$CONFIG{'version'} 
            = "# Version Information\n"
            . "# Program Version Information\n"
            . "#   Author:        $CONFIG{'author'}\n"
            . "#   Revised:       $CONFIG{'checkedin'}\n"
            . "#   Versions\n"
            . "#     Main:          $CONFIG{'revision'}\n"
            . "#     SASA:          $RotLib::SASA::VERSION\n"
            . "# Current Execution\n"
            . "#   Title:         $CONFIG{'title'}\n"
            . "#   Configuration: $CONFIG{'configuration'}\n"
            . "#   Proteins:      $CONFIG{'protein_file'}\n"
            . "#   User:          $CONFIG{'user'}\n"
            . "#   Host:          $CONFIG{'host'}\n"
            . "#   Time:          $CONFIG{'start_time'}\n"
            . "#   CWD:           $CONFIG{'pwd'}\n"
            ;

# Print welcome and configuration
print "Welcome to $0\n"
    . "If you have problems or suggestions,\n"
    . "please contact Alex at scouras\@u.washington.edu\n\n"
    . "$CONFIG{'version'}";
    ;



####################################################################
#                                                     INITIALIZATION
####################################################################

my %PROTEINS = Load_Protein_List ( \%CONFIG, \%AA );

# GLOBAL ANALYSIS OBJECTS
my $SASA  = RotLib::SASA        ->Initialize (\%CONFIG, \%AA, \%PROTEINS);

#----- OUTPUT FOR INDIVIDUAL AMINO ACIDS

my %OUTPUT = ();
my %HEADERS = ();
my %CHECK_S2 = ();

foreach my $aa ( grep { $_ eq uc $_ } keys %AA ) {
  foreach my $sasa ( '.', 0, 1, 2 ) {
    my $dir = "$CONFIG{'output_dir'}/$aa/$sasa";
    Make_Directories ($dir);
    open $OUTPUT{$aa}{$sasa}, ">$dir/dynamics.residues.dat" 
      or die "Couldn't create dynamics residues file. $!";
  }
}





####################################################################
#                                                       PROTEIN LOOP
####################################################################

my $protein_count = 0;
my $protein_total = scalar keys %PROTEINS;
my $RES_TOTAL = Sum ( [ map { $AA{$_}{'precount'} } @{$CONFIG{'residue_list'}}] );

foreach my $protein_name ( sort keys %PROTEINS ) {
  $protein_count++;
  my %protein = %{$PROTEINS{$protein_name}};
  my $protein_dir = $protein{'dir'};

  print "\n\n";
  my $RES_DONE = Sum ( [ map { $AA{$_}{'count'} } @{$CONFIG{'residue_list'}}] );
  mark_time ( $LAP, "Starting a new Protein", 1, $RES_DONE, $RES_TOTAL );
  #mark_time ( \$LAP, "Starting a new Protein", 1, $protein_count, $protein_total );
  print "Protein:         $protein_name\n"
      . "|-Number:        $protein_count/$protein_total\n"
      . "|-Directory:     $protein{'dir'}\n"
      . "|-Subdirs (" . (scalar @{$protein{'subdirs'}}) .    "):   " 
                      . (join ", ", @{$protein{'subdirs'}}) . "\n"
      . "|-Length:        $protein{'length'} residues\n"
      . "|-Residue Range: $protein{'residue_range_string'}\n"
      . "|-Time Range:    $protein{'time_range_string'}\n"
      ;


  ##################################################################
  #  RESIDUE LOOP - Generate and aggregate rotamers for each residue
  #-----------------------------------------------------------------
  # The raw data is stored in a separate file for each angle 
  # ('<angle>_t.dat'), which is a pain to work with, so we have the 
  # shell combine them for us (and much faster than perl would do it)
  #
  # Skip first and last residue because they do not have phi/psi data.
  # Note that we've indexed by residue number, so counting starts at 1.
  ##################################################################

  my @sequence      = @{$protein{'sequence'}};
  my @sequence_full = @{$protein{'sequence_full'}};
  my ( $res_start, $res_stop ) = (1, $#sequence);
  if ( $CONFIG{'skip_terminal_residues'} ) {
    print ' ';
    $res_start = 2;
    $res_stop = $#sequence - 1;
  }
  foreach my $res_num ($res_start..$res_stop ) {
    my $res_name = $sequence[$res_num];
    my $res_name_full = $sequence_full[$res_num];
    

    #=========== Do we process this residue?
    if ( In_Range ( $protein{'residue_intervals'}, $res_num ) 
        and ( defined $res_name )
        and ( exists $AA{$res_name} )
        and ( (not $CONFIG{'skip_terminal_residues'}) or $res_name_full !~ /_(N|C)$/ )
        and ( not $CONFIG{'residue_string'} 
             or grep { $_ eq $res_name } @{$CONFIG{'residue_list'} } ) 
      ) {
      print $AA{$res_name}{'ab'};
      if    (not $res_num % $CONFIG{'sequence_break'}) { print "\n" }
      elsif (not $res_num % $CONFIG{'sequence_space'}) { print " "  }
    } else {
      print '_';
      if    (not $res_num % $CONFIG{'sequence_break'}) { print "\n" }
      elsif (not $res_num % $CONFIG{'sequence_space'}) { print " "  }
      next;
    }
    $AA{$res_name}{'count'}++;

    
    
    
    ################################################################
    # SUBDIRECTORY LOOP 
    #---------------------------------------------------------------
    ################################################################
    my $res_dir = "$res_num\_$res_name";
    my $subdir_count = 0;
    my @sasas = ();
    my @sasa_bins = ();
    MAIN: foreach my $subdir ( @{$protein{'subdirs'}} ) {

      my $sim_dir = "$protein{'dir'}/$subdir";

      my $molecule_dir  = $protein{'subdir_data'}{$subdir}{'molecule_dir'};
      my $dir = "$molecule_dir/$res_dir";
      my $dir_out = "$dir/$CONFIG{'rotamer_mode'}";

      #---------- SASA Data
      my ($sasa, $sasa_bin) = $SASA->Determine_SASA ( \%protein, $subdir, $res_num );
      push @sasas, $sasa;
      push @sasa_bins, $sasa_bin;


      
      #---------- S2 Data (vs. NMR)
      my $files_s2 = "$sim_dir/s2/s2\.*\.dat";
      my @files_s2 = glob($files_s2);
      if ( not scalar @files_s2 ) { 
        next MAIN;
        #die "Couldn't find s2 files matching $files_s2";
      }
      my @S2_RAW = split /\n/, `egrep "^$res_dir" $files_s2`;
      my %S2 = ();
      foreach my $s2 ( @S2_RAW ) {
        my ( $d, $t, $s ) = split /\s+/, $s2;
        if (not defined $s) { next MAIN }
        $d =~ /\b$res_dir\_(\w+).s2.dat$/ or die "S2. $!";
        my $y = $1;
        $S2{$y}{$t} = $s;
        #print "\n$d\t$y\t$t\t$s\n";
      }


      #---------- S Data (Dave's)
      my $ANGLES = $AA{$res_name}{'all'};
      my @S_RAW = ();
      my %S;
      foreach my $angle ( @$ANGLES) {
        my $base_dh = "$molecule_dir/$res_dir/$angle.dat";
        if ( not -e $base_dh ) { 
          $base_dh =~ s/\/work\/scratch\/rotamers\/dynameomics/\/work\/analysis/;
        }
        if ( not -e $base_dh ) { 
          next MAIN;
          #die "Can't find diheral file $base_dh";
        }
        $S{$angle} = (split /\s+/, `tail -n 1 $base_dh`)[-1];
        if ( not $S{$angle} ) { 
          next MAIN;
          #die "Couldn't find S for $protein_name $res_dir $base_dh. $!"; 
        }
        #print "S\t$angle\t$S{$angle}\n";
      }



      #---------- Waiting Time Data (From me)
     
      my %WAITS = ();
      my $file_wait = "$molecule_dir/$res_dir/dynamic/dynamics_values.mean_counts.dat";
      my $dynamic_data;
      if    ( -e $file_wait      ) { $dynamic_data = `cat $file_wait     | transpose` } 
      elsif ( -e "$file_wait.gz" ) { $dynamic_data = `zcat $file_wait.gz | transpose` }
      
      if ( defined $dynamic_data ) { 
        foreach my $line ( split /\n/, $dynamic_data ) { 
          my ( $angle, $wait ) = split /\s+/, $line;
          next if not grep { lc $angle eq lc $_ } @$ANGLES, "major";
          $WAITS{$angle} = $wait;
          #print "WAITS\t$angle\t$wait\n";
        }
      }


      #---------- Rotamer Distribution Data (From me)
      my $file_rot    = "$molecule_dir/$res_dir/static/library.bbind.dat";
      my $file_rot_gz = "$molecule_dir/$res_dir/static/library.bbind.dat.gz";
      my @ROTS = (1,0,0);
      if ( -e $file_rot ) { 
        @ROTS = reverse split /\n/, `cat $file_rot | transpose | grep "p(r1234)" | transpose | grep -v "p" | sort -n`;
        push @ROTS, 0,0,0,0,0,0,0;
        #print join "\t", @ROTS[0..2], "\n";
      } elsif ( -e $file_rot_gz ) { 
        @ROTS = reverse split /\n/, `zcat $file_rot | transpose | grep "p(r1234)" | transpose | grep -v "p" | sort -n`;
        push @ROTS, 0,0,0,0,0,0,0;
        #print join "\t", @ROTS[0..2], "\n";
      }


      #---------- OUTPUT
      
      my $ROTS_OUT = 3;

      my @headers = ();

      # Waits
      push @headers, map {"WAITS_$_"} ( sort keys %WAITS );

      # Rotamers
      push @headers, map {"ROT_$_"} (1..$ROTS_OUT);

      # S2
      push @headers, map { my $x=$_; map {"S2_$x\_$_"} (sort {$a<=>$b} keys %{$S2{$x}})} ( sort keys %S2 );

      # S
      push @headers, map {"S_$_"} ( sort keys %S );


      ########## Create headers for each amino acid / sasa
      if ( not defined $HEADERS { $res_name } ) {
        my $header = "#PROTEIN\tINDEX\tRESNAME\tSASA\tSASA_BIN\t"
                   . (join "\t", @headers) 
                   .  "\n";

        $HEADERS{$res_name} = \@headers;

        for my $sasa ( '.', 0, 1, 2 ) {
          print {$OUTPUT{$res_name}{$sasa}} $header;
        }

      ########## PRINT DATA
      } else { 

        if ( (scalar @headers) != ( scalar @{$HEADERS{$res_name}} ) ) { 
          next MAIN;
          die "Unequal header lengths for $protein_name, $res_num, $res_name\n"
            . "HAS:   " . (join "\t", @headers) . "\n"
            . "NEEDS: " . (join "\t", @{$HEADERS{$res_name}}) . "\n"
            ;
        }

        foreach my $i ( 0..$#headers ) { 
          if ( $headers[$i] ne $HEADERS{$res_name}[$i] ) { 
            next MAIN;
            die "Unequal headers for $protein_name, $res_num, $res_name\n"
              . "HAS:   " . (join "\t", @headers) . "\n"
              . "NEEDS: " . (join "\t", @{$HEADERS{$res_name}}) . "\n"
          }
        }
      }


      # Print data

      my $line = sprintf "%s\t%u\t%s\t%.2f\t%u",
                    $protein_name, $res_num, $res_name, $sasa, $sasa_bin;

      # waits
      $line .= join "", map { sprintf "\t%.2f", $WAITS{$_} } ( sort keys %WAITS );

      #rotamers
      $line .= join "", map { sprintf "\t%.3f", $_ } @ROTS[0..($ROTS_OUT-1)];

      # S2
      $line .= join "", map { my $x=$_; map { sprintf "\t%.3f", $S2{$x}{$_} } ( sort {$a<=>$b} keys %{$S2{$x}} ) } ( sort keys %S2 );

      # S
      $line .= join "", map { sprintf "\t%.3f", $S{$_} } ( sort keys %S );
        
      $line .= "\n";

      print {$OUTPUT{$res_name}{'.'}} $line;
      print {$OUTPUT{$res_name}{$sasa_bin}} $line;


    }
  }
}





####################################################################
#                                                                   
#                                                        SUBROUTINES
#                                                                   
####################################################################

################################################## LOAD PROTEIN LIST
# TODO: Make individual subdirectories of a protein able to handle 
#       different directories, residues, and time selections.
sub Load_Protein_List { 
  my $CONFIG    = $_[0];
  my $AA        = $_[1];
  
  
  my %PROTEINS = ();

  
  
  #----- Set counts of amino acids to 0
  for my $res ( keys %$AA ) { 
    $AA->{$res}{'precount'} = 0; 
    $AA->{$res}{'count'   } = 0; 
  }
  
  #-------------------------------------- Read the lines of the file
  my $file = $CONFIG->{'protein_file'};
  my $line;
  open PRO, $file or die "Couldn't open protein file, '$file'. $!";

  while ( defined ( $line = <PRO> ) ) {
    next if ( ( $line = Clean_Line($line) ) eq '' );
    
    my ( $protein_name, $dir, $subdir, $residue_range, $time_range ) 
      = map { Trim($_) } split ';', $line;

    # These values default to "all" if empty.
    $subdir         = '*' if not defined $subdir        or $subdir        eq '';
    $residue_range  = '*' if not defined $residue_range or $residue_range eq '';
    $time_range     = '*' if not defined $time_range    or $time_range    eq '';
    
      
    # Parse protein subdirectories (default all subdirs unless specified)
    my @subdirs = ();
    foreach my $d ( map { /^\s*\/?(.*?)\s*$/; $1 } split /\,/, $subdir ) {
      push @subdirs, map { m/$dir\/(.*$)/; $1 } grep { -d $_ } glob ( "$dir/$d" );
    }

    if ( not @subdirs ) { next; } # Skip proteins without simulations 
    #------------------------------------------ Parse Residue Ranges
    $residue_range =~ s/\s//g;
    my %residue_intervals = ();
    Process_Range($protein_name, $dir, 'residue', $residue_range, \%residue_intervals);
    #--------------------------------------------- Parse Time Ranges
    $time_range =~ s/\s//g;
    my %time_intervals = ();
    Process_Range($protein_name, $dir, 'time', $time_range, \%time_intervals);

    

    #################################################### THE PROTEIN
    my %protein =  
    (
      'name'                  => $protein_name,
      'dir'                   => $dir,
      'subdir_string'         => $subdir,
      'residue_range_string'  => $residue_range,
      'time_range_string'     => $time_range,
      'outdir'                => Clean_Filename ("$dir/$CONFIG{'protein_summary_dir'}"),
      'subdir_data'           => { map { $_ => {} } @subdirs } ,
      'residue_intervals'     => \%residue_intervals,
      'time_intervals'        => \%time_intervals,
    );

    #---------- FIND EACH SUBDIR'S DIHEDRAL AND MOLECULE DIRECTORIES
    # find all the dihedral dirs.  Take the simple one if it exists, 
    # or the first one otherwise.
    # TODO: Give some way to specify which dihedral dir.
    # $molecule_dir contains the protein and subdir path.
    my $are_good_molecule_dirs = 0;
    foreach my $subdir ( @subdirs ) {
      
      my @dihedral_dirs = grep { -d $_ } 
                 glob ( "$dir/$subdir/$CONFIG{'dihedral_dir_preferred'}" );
      if ( not @dihedral_dirs ) {
        @dihedral_dirs = grep { -d $_ } 
                 glob ( "$dir/$subdir/$CONFIG{'dihedral_dirs'}" ); }
      my @molecule_dirs = ();
      foreach my $dd ( @dihedral_dirs ) {
        push @molecule_dirs, grep { /\d+_\w+$/ and -d $_ } glob ( "$dd/*_*");
      }
      @molecule_dirs = sort @molecule_dirs;
      
      # Multilple molecules, dunno which one to take.
      if (scalar @molecule_dirs > 1) { 
        @molecule_dirs = $molecule_dirs[0];
#        warn "For protein $protein_name, subdir $subdir, there is more than one molecule "
#           . "in the dihedral directory. We don't know which one "
#           . "to use, because we're a little dumb for now. So we're "
#           . "skipping this subdirectory. Directories: \n" 
#           . (map { sprintf "\t$_\n" } @molecule_dirs) . "). $!";
#        next;
      # Error, no molecules
      } elsif ( not @molecule_dirs ) {
        warn "For protein $protein_name, subdir $subdir, "
           . "there are no dihedral directories, so we are skipping it.\n";
           ;
        next;
      }
      $protein{'subdir_data'}{$subdir}{'molecule_dir'} = $molecule_dirs[0];
      $are_good_molecule_dirs = 1;
    }
    if ( not $are_good_molecule_dirs ) {
      warn "There are no dihedral data directories in any subdirectory "
         . "for the protein $protein_name.  It will be completely skipped. \n";
      next;
    }

    #-------------------------- READ AND CHECK THE PROTEIN SEQUENCES
    # This first directory shall be considered the standard.  The 
    # sequence and length of the protein shall be read from here; 
    # all other subdirectories will be compared to this one.

    my $consensus_on_protein_sequence = 1;
    foreach my $subdir ( @subdirs ) {
      my $molecule_dir = $protein{'subdir_data'}{$subdir}{'molecule_dir'};

      #---------------------------------------- GET LIST OF RESIDUES
      # Each residue in the protein has its own directory 
      # (like "23_LYS") with its angle information, so we read the 
      # protein sequence from the directory listing.

      my @residue_dirs = reverse sort 
                                   map  { m/$molecule_dir\/(.*?)$/; $1 }
                                     grep { -d $_ and /\/\d+_\w\w\w(_(C|N))?$/} 
                                          glob ("$molecule_dir/*");
     
      #----- Generate sequence from directory listing
      #----- Remove all _C, _N, _whatever subscripts from @sequence
      my @sequence = (undef);  # no 0th residue, 1-indexed array!
      my @sequence_full = (undef);
      for my $res ( @residue_dirs ) {
        my ($num, $name, $sub) = split '_', $res; 
        $sequence[$num] = $name;
        $sequence_full[$num] = $name . (defined $sub ? "_$sub" : '');
      }
      
      #----- Check that sequences are identical
      # first simulation for protein, so nothing to verity against.
      if ( not $protein{'length'} ) { 
        $protein{'length'} = $#sequence;
        $protein{'sequence'} = \@sequence;
        $protein{'sequence_full'} = \@sequence_full;
        foreach my $res ( @sequence ) {
          next if not $res or not exists $AA->{$res};
          $AA->{$res}{'precount'}+=1;
        }
      } else { 
        if ( ( $protein{'length'} != $#sequence ) or
             ( grep { not $sequence[$_] 
                      eq $protein{'sequence'}[$_] } 
                   1..$protein{'length'} ) ) {
          warn "For protein $protein_name, simulation replicates have "
             . "different sequences.  We will therefore completely "
             . "skip this protein.\n";
          $consensus_on_protein_sequence = 0;
          last;
        }
      }
    }

    # Create data directory for this protein
    if ( not -e "$dir/$CONFIG{'protein_summary_dir'}" ) {
      mkdir "$dir/$CONFIG{'protein_summary_dir'}" 
        or die "Couldn't make output directory $dir/$CONFIG{'protein_summary_dir'}. $!";
    }
      
    # Add the subdirectories that actually passed muster
    $protein{'subdirs'}    = [sort keys %{$protein{'subdir_data'}}];
    $protein{'replicates'} = scalar keys %{$protein{'subdir_data'}};

    $PROTEINS{$protein_name} = \%protein;

  }
  close PRO or die "Couldn't close protein file, '$file'. $!";

  if ( wantarray )  { return %PROTEINS } 
  else              { return \%PROTEINS }
}





####################################################################
#                                                 TIMING SUBROUTINES
####################################################################
sub mark_time {
  my $lap   = $_[0];
  my $note  = $_[1];
  my $level = $_[2] || $CONFIG{'timing_defalut'};
  my $at    = $_[3] || 1;
  my $total = $_[4] || 1;

  return if $CONFIG{'timing'} < $level;
  my $togo = ( $total ? $total - $at : 0 );
  my $last_time = $lap->{'time'};
  my $last_at   = $lap->{'at'};

  my $now   = time;
  my $elapsed_time = $now-$last_time || 1;
  my $elapsed_at   = $at - $last_at || 1;

  printf "Total: " . (make_hour_min_sec($now-$START)) . "  "
       . "Lap: "   . (make_hour_min_sec($now-$last_time)) 
       . ( $togo 
            ? "  ETA: " . (make_hour_min_sec(($now-$START)/$at*$togo)) 
              . " - " . (make_hour_min_sec(($elapsed_time/$elapsed_at)*$togo))
            : "" )
       . ".  " . $note . "\n";
  $lap->{'time'} = $now;
  $lap->{'at'} = $at;
  
}

sub make_hour_min_sec {
  my $seconds = $_[0];
  my $hoursec = 60*60;
  my $minsec  = 60;
  my $secsec  = 1;

  my $string = sprintf "%02u:%02u:%02u", 
   POSIX::floor(($seconds           ) / $hoursec),
   POSIX::floor(($seconds % $hoursec) / $minsec ),
   POSIX::floor(($seconds % $minsec ) / $secsec ),
   ;  
  return $string;
}




