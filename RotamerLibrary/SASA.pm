package RotLib::SASA;

#use 5.008006;
use strict;
use warnings;

use Utility qw(:all);
use Data::Dumper;

require Exporter;

our @ISA = qw(Exporter);

# Items to export into callers namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use RotLib ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = ( 'all' => [ qw(
	
) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw(
	
);


# CVS VERSION INFORMATION (AUTOMAGICALLY GENERATED BY CVS)
'$Revision: 1.1.1.1 $'              =~ /^.Revision: (.*) \$/; our $VERSION    = $1;
'$Date: 2009/03/25 18:32:30 $'  =~ /^.Date: (.*) \$/;     our $CHECKED_IN = $1;
'$Author: scouras $'            =~ /^.Author: (.*) \$/;   our $AUTHOR     = $1;


our %CONFIG_SASA = (

  max_bins        =>     0,  
  min_sasa_length => 19000,
  increment       =>  1000,
  min_sasa_count  =>    10,
  dir             => 'sasa',
  base_file       => 'sasa_t.dat',
  cache_file_old  => 'dihedral_sasa_cache_old.dat',
  cache_file      => 'dihedral_sasa_cache.dat',
  files           => { sasa_def_file => 'sasa.dat' },
  
);


######################################################### INITIALIZE

sub Initialize {

  my $class     = $_[0];
  my $CONFIG    = $_[1];
  my $AA        = $_[2];
  my $PROTEINS  = $_[3];

  my $SASA = \%CONFIG_SASA;
  bless $SASA, $class;
  
  $SASA->{'main'} = $CONFIG;
  $SASA->{'files'}{'sasa_def'} = "$CONFIG->{'root_dir'}/$SASA->{'files'}{'sasa_def_file'}";
  $SASA->{'do_global_sasa'} = 0;

  if ( not $CONFIG->{'sasa'} ) { return $SASA }
  
  #----------------------------------------- Read the SASA data file
  
  my $file = $SASA->{'files'}{'sasa_def'};
  if ( not $file or not -e $file ) { 
    return $SASA;
  }
    
  my $line;
  my $max_bins = 0;
  open SASA, $file or die "Couldn't open sasa definition file, '$file'. $!";
  while ( defined ( $line = <SASA> ) ) {
    next if ($line = Trim ( $line )) eq '';
    my ( $res, @breaks ) = split /\s+/, $line;
    $max_bins = Max ( $max_bins, scalar @breaks + 1 );
    $SASA->{'bins'}{$res} = \@breaks;
  }
  close SASA or die "Couldn't close sasa definition file, '$file'. $!";
  
  
  #----------------------------------- Find SASA Dir for Each Subdir
  foreach my $protein_name ( sort keys %$PROTEINS ) {
    my $protein = $PROTEINS->{$protein_name};
    my $missing_sasa = 0;
    my $sasa_dir;
    foreach my $subdir ( @{$protein->{'subdirs'}} ) {
      $sasa_dir = (glob("$protein->{'dir'}/$subdir/$SASA->{'dir'}/0_*"))[0];
      $missing_sasa = 0;

      # Check if dir is missing
      if ( not defined $sasa_dir or not $sasa_dir or not -e $sasa_dir ) { 
        $missing_sasa = "Sasa directory not found for $protein_name $subdir";
        next;
      }
      
      # Missing data files?
      my $sasa_file = "$sasa_dir/$SASA->{'base_file'}";
      if ( not -e $sasa_file ) { 
        $missing_sasa = "Sasa data not found for $protein_name $subdir ($sasa_file)";
        next;
      }

      # Is it long enough?
      my $length = `tail -n 1 $sasa_file | cut -f 1 2>&1`;
      if ( (not defined $length) or (not length ($length))) { 
        $missing_sasa = "Couldn't get length from sasa file $protein_name $subdir ($sasa_file): '$length'";
        next;
      }
       
      $length = Utility::Trim($length);
      if ( not $length =~ /^([\d\.])+$/ ) { 
        $missing_sasa = "Couldn't parse length from sasa file $protein_name $subdir ($sasa_file): '$length'";
        next;
      }

      if ( $length < $SASA->{'min_sasa_length'} ) { 
        $missing_sasa = "Sasa data isn't long enough ($length ps vs. $SASA->{'min_sasa_length'} ps) for $protein_name $subdir ($sasa_file)";
        next;
      }

    } continue { 
      # Print message and skip if missing sasa
      if ( $missing_sasa ) { 
        print "$missing_sasa\n";
        $protein->{'subdir_data'}{$subdir}{'do_sasa'} = 0;
      
      # All Good
      #print "Sasa was found $protein_name $subdir\n";
      } else { 
        $protein->{'subdir_data'}{$subdir}{'sasa_dir'} = $sasa_dir;
        $protein->{'subdir_data'}{$subdir}{'do_sasa'}  = 1;
      }
    }
  }
  
  $SASA->{'do_global_sasa'} = 1;
  $SASA->{'max_bins'} = $max_bins;

  return $SASA;
}



################################################# DETERMINE SASA BIN

sub Determine_SASA {

  my $self    = $_[0];
  my $protein = $_[1];
  my $subdir  = $_[2];
  my $res_num  = $_[3];
 
  # TODO: FIX SASA 
  # skip subdirs without sasa data.

  if ( not $protein->{'subdir_data'}{$subdir}{'do_sasa'} ) { return (0, 1) }
  my $res_name = $protein->{'sequence'}[$res_num];
  my $sasa_dir   = $protein->{'subdir_data'}{$subdir}{'sasa_dir'};
  my $sasa_file  = "$sasa_dir/$res_num\_$res_name\_t.dat";
  my $sasa_cache      = "$sasa_dir/$self->{'cache_file'}";
  my $sasa_cache_old  = "$sasa_dir/$self->{'cache_file_old'}";

  #===== Check cache for data
  my ($sasa, $sasa_bin, $sasa_count);
  my $refresh_cache = 0;
  my $searched_cache_file;
  my $line;
  if ( -e $sasa_cache ) { 
    $line = `grep -a "^$res_num\t$res_name\t" $sasa_cache | head -n 1`;
  } 

  if ( not $line and -e $sasa_cache_old ) { 
    $line = `grep -a "^$res_num\t$res_name\t" $sasa_cache_old | head -n 1`;
    $refresh_cache = 1;
  }

  if ( $line ) {
    #print "  line = $line\n";
    $line =~ /^(\d+)\t(\w+)\t([\d\.]+)\t(\d)$/ 
      or die "Couldn't parse sasa cache line, '$line'";
    $sasa = $3;
  }

  #===== Calculate data ourselves 
  if ( not defined $sasa ) { 
    #print "Cache was empty.  Calculating sasa\n";
    if ( not -e $sasa_file ) { die "Couldn't find sasa file, '$sasa_file'."; }
    my @samples = Interval_Samples ( $protein->{'time_intervals'}, $self->{'increment'} );
    my $sasa_cmd = "egrep \"" 
                 . ( join "|", map { "^$_\\." } ( @samples ) ) 
                 . "\" $sasa_file | cut -f 3";

   
    $sasa = 0;  
    my $sasa_count = 0;
    foreach my $line ( split "\n", `$sasa_cmd` ) { 
      $sasa += $line; 
      $sasa_count++;
    }
    #if ( $sasa_count < $self->{'min_sasa_count'} ) {
    #  print "Not enough timepoints for average sasa calculation for $protein->{'name'}: $subdir\n"; 
    #  return (0, 1);
    #  #die "Not enough timepoints for average sasa calculation for $protein->{'name'}: $subdir\n"; 
    #}
    $sasa /= $sasa_count;
    $refresh_cache = 1;

  }
  
  $sasa_bin = $self->Determine_SASA_Bin ( $res_name, $sasa );
  $self->{'count'}{$res_name}[$sasa_bin]++;

  if ( $refresh_cache ) { 
    `echo "$res_num\t$res_name\t$sasa\t$sasa_bin" >> $sasa_cache`;
  }
  #print "Calulating sasa for protein $protein->{'name'} $sasa $sasa_bin $sasa_count\n";
  
  if ( wantarray ) { return ($sasa, $sasa_bin) }
  else             { return $sasa }

};


sub Determine_SASA_Bin {
  my $self      = $_[0];
  my $res_name  = $_[1];
  my $sasa      = $_[2];
  
  return 1 if ( not defined $sasa);
  my $bins = $self->{'bins'}{$res_name};
  foreach my $bin ( 0..$#$bins ) {
    if ( $sasa < $bins->[$bin] ) { return $bin }
  }
  return $#$bins+1;
}

1;
__END__


